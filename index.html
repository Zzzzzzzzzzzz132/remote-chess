<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ËøúÁ®ãË±°Ê£ã - ‰∏éÂß•Áà∑ÂØπÂºà</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: "Microsoft YaHei", "SimSun", sans-serif;
            background: linear-gradient(135deg, #f5f5dc 0%, #e8dcc0 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            color: #8b4513;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            font-size: 1.1em;
        }
        
        .game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1200px;
            width: 100%;
        }
        
        .board-wrapper {
            position: relative;
            background: #f0d9b5;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 3px solid #8b4513;
        }
        
        .board {
            width: 450px;
            height: 500px;
            position: relative;
            background: #f0d9b5;
        }
        
        .board-lines {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .horizontal-lines, .vertical-lines {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .horizontal-line {
            position: absolute;
            width: 100%;
            height: 1px;
            background: #333;
        }
        
        .vertical-line {
            position: absolute;
            width: 1px;
            height: 100%;
            background: #333;
        }
        
        .palace-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .palace-line {
            position: absolute;
            width: 141px;
            height: 1px;
            background: #333;
            transform-origin: left center;
        }
        
        .palace-line.top-left { top: 50px; left: 154px; transform: rotate(45deg); }
        .palace-line.top-right { top: 50px; right: 154px; transform: rotate(-45deg); }
        .palace-line.bottom-left { bottom: 50px; left: 154px; transform: rotate(-45deg); }
        .palace-line.bottom-right { bottom: 50px; right: 154px; transform: rotate(45deg); }
        
        .river {
            position: absolute;
            top: 225px;
            left: 0;
            width: 100%;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #8b4513;
            font-weight: bold;
            letter-spacing: 20px;
        }
        
        .pieces-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .piece {
            position: absolute;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            z-index: 10;
        }
        
        .piece.red {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #cc0000);
            color: #ffeb3b;
            border: 2px solid #8b0000;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .piece.black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            color: #fff;
            border: 2px solid #333;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .piece:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255,215,0,0.8);
        }
        
        .piece.selected {
            box-shadow: 0 0 20px #ffd700, 0 0 40px #ffd700;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1.1); }
            50% { transform: scale(1.2); }
        }
        
        .piece.last-move {
            border: 3px solid #00ff00;
        }
        
        .piece.check {
            animation: check-pulse 0.5s infinite;
            box-shadow: 0 0 20px #ff0000;
        }
        
        @keyframes check-pulse {
            0%, 100% { box-shadow: 0 0 20px #ff0000; }
            50% { box-shadow: 0 0 40px #ff0000, 0 0 60px #ff0000; }
        }
        
        .move-hint {
            position: absolute;
            width: 16px;
            height: 16px;
            background: rgba(0,255,0,0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
        }
        
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 320px;
        }
        
        .panel-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            border: 2px solid #8b4513;
        }
        
        .section-title {
            font-weight: bold;
            color: #8b4513;
            margin-bottom: 15px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .timer-box {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
        }
        
        .timer {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background: #f5f5f5;
            min-width: 80px;
        }
        
        .timer.active {
            background: #e3f2fd;
            border: 2px solid #2196f3;
        }
        
        .timer-label {
            font-size: 0.8em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .timer-time {
            font-size: 1.5em;
            font-weight: bold;
            font-family: monospace;
        }
        
        .timer.red .timer-time { color: #c62828; }
        .timer.black .timer-time { color: #333; }
        
        .status-content {
            color: #333;
            line-height: 1.6;
        }
        
        .player-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .player-badge.red {
            background: #ffeb3b;
            color: #c62828;
        }
        
        .player-badge.black {
            background: #333;
            color: #fff;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }
        
        .btn-primary {
            background: #8b4513;
            color: white;
        }
        
        .btn-primary:hover {
            background: #6b3410;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: #e0e0e0;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #d0d0d0;
        }
        
        .btn-danger {
            background: #c62828;
            color: white;
        }
        
        .btn-danger:hover {
            background: #a02020;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 250px;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            background: #f9f9f9;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
        }
        
        .chat-message {
            margin-bottom: 8px;
            padding: 6px 10px;
            border-radius: 12px;
            max-width: 85%;
            word-wrap: break-word;
            font-size: 0.9em;
        }
        
        .chat-message.own {
            background: #dcf8c6;
            margin-left: auto;
            text-align: right;
        }
        
        .chat-message.other {
            background: #fff;
            border: 1px solid #e0e0e0;
        }
        
        .chat-message.system {
            background: #fff3cd;
            text-align: center;
            font-size: 0.8em;
            color: #856404;
            max-width: 100%;
        }
        
        .chat-sender {
            font-size: 0.75em;
            color: #666;
            margin-bottom: 2px;
        }
        
        .chat-input-area {
            display: flex;
            gap: 8px;
        }
        
        .chat-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
            font-family: inherit;
        }
        
        .chat-send {
            padding: 8px 16px;
            background: #8b4513;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
        }
        
        .chat-send:hover {
            background: #6b3410;
        }
        
        .moves-list {
            max-height: 150px;
            overflow-y: auto;
            background: #f9f9f9;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9em;
        }
        
        .move-item {
            padding: 4px 0;
            border-bottom: 1px solid #eee;
            color: #555;
            display: flex;
            justify-content: space-between;
        }
        
        .move-number {
            color: #999;
            min-width: 30px;
        }
        
        .move-red { color: #c62828; }
        .move-black { color: #333; }
        
        .undo-request {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
        }
        
        .undo-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .undo-buttons .btn {
            margin: 0;
            flex: 1;
            padding: 8px;
            font-size: 14px;
        }
        
        .connection-status {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 0.85em;
            margin-top: 10px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ccc;
        }
        
        .status-dot.connected {
            background: #4caf50;
            animation: blink 2s infinite;
        }
        
        .status-dot.syncing {
            background: #ff9800;
            animation: blink 0.5s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 10px 0;
        }
        
        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
            background: #ccc;
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle.active {
            background: #4caf50;
        }
        
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        
        .toggle.active .toggle-slider {
            transform: translateX(24px);
        }
        
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        .toast.show {
            opacity: 1;
        }
        
        .role-selector {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }
        
        .role-btn {
            flex: 1;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .role-btn:hover {
            border-color: #8b4513;
            background: #f5f5f5;
        }
        
        .role-btn.selected {
            border-color: #8b4513;
            background: #e8dcc0;
        }
        
        .role-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #f0f0f0;
        }
        
        .role-btn.red {
            border-color: #c62828;
        }
        
        .role-btn.black {
            border-color: #333;
        }
        
        @media (max-width: 800px) {
            .board {
                width: 360px;
                height: 400px;
            }
            .piece {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            .side-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üèÆ ËøúÁ®ãË±°Ê£ã üèÆ</h1>
        <p class="subtitle">‰∏éÂß•Áà∑ÈöîÁ©∫ÂØπÂºàÔºåË∑®Ë∂ä‰∏áÈáåÁöÑ‰∫≤ÊÉÖ</p>
    </div>
    
    <div class="game-container">
        <div class="board-wrapper">
            <div class="board" id="board">
                <div class="board-lines">
                    <div class="horizontal-lines" id="hLines"></div>
                    <div class="vertical-lines" id="vLines"></div>
                    <div class="palace-lines">
                        <div class="palace-line top-left"></div>
                        <div class="palace-line top-right"></div>
                        <div class="palace-line bottom-left"></div>
                        <div class="palace-line bottom-right"></div>
                    </div>
                </div>
                <div class="river">Ê•ö Ê≤≥ Ê±â Áïå</div>
                <div class="pieces-container" id="piecesContainer"></div>
            </div>
        </div>
        
        <div class="side-panel">
            <!-- ÈÄâÊã©ÈòµËê• -->
            <div class="panel-section" id="roleSelection">
                <div class="section-title">üé≠ ÈÄâÊã©ÈòµËê•</div>
                <div class="role-selector">
                    <div class="role-btn red" id="btnRed" onclick="selectRole('red')">
                        <div style="font-size:2em;">üî¥</div>
                        <div>Á∫¢Êñπ</div>
                        <div style="font-size:0.8em;color:#666;">ÂÖàÊâã</div>
                    </div>
                    <div class="role-btn black" id="btnBlack" onclick="selectRole('black')">
                        <div style="font-size:2em;">‚ö´</div>
                        <div>ÈªëÊñπ</div>
                        <div style="font-size:0.8em;color:#666;">ÂêéÊâã</div>
                    </div>
                </div>
                <div style="text-align:center;color:#666;font-size:0.9em;">
                    Âß•Áà∑ÈÄâÂè¶‰∏Ä‰∏™È¢úËâ≤Âç≥ÂèØ
                </div>
            </div>
            
            <!-- ËÆ°Êó∂Âô® -->
            <div class="panel-section">
                <div class="section-title">‚è±Ô∏è ËÆ°Êó∂Âô®</div>
                <div class="timer-box">
                    <div class="timer red" id="timerRed">
                        <div class="timer-label">Á∫¢Êñπ</div>
                        <div class="timer-time" id="timeRed">10:00</div>
                    </div>
                    <div class="timer black" id="timerBlack">
                        <div class="timer-label">ÈªëÊñπ</div>
                        <div class="timer-time" id="timeBlack">10:00</div>
                    </div>
                </div>
            </div>
            
            <!-- Ê∏∏ÊàèÁä∂ÊÄÅ -->
            <div class="panel-section">
                <div class="section-title">üéÆ Ê∏∏ÊàèÁä∂ÊÄÅ</div>
                <div class="status-content">
                    <div>ÂΩìÂâçÂõûÂêà: <span id="currentTurn" style="font-weight:bold;">Á∫¢Êñπ</span></div>
                    <div>‰Ω†ÊòØ: <span id="playerRole" class="player-badge">Êú™ÈÄâÊã©</span></div>
                    <div class="connection-status">
                        <span class="status-dot" id="statusDot"></span>
                        <span id="statusText">ËøûÊé•‰∏≠...</span>
                    </div>
                </div>
                <div id="undoRequestArea" style="display:none;"></div>
            </div>
            
            <!-- ËÅäÂ§© -->
            <div class="panel-section">
                <div class="section-title">üí¨ ËÅäÂ§©</div>
                <div class="chat-container">
                    <div class="chat-messages" id="chatMessages">
                        <div class="chat-message system">Ê¨¢ËøéÊù•Âà∞ËøúÁ®ãË±°Ê£ãÔºÅÂÖàÈÄâÊã©ÈòµËê•...</div>
                    </div>
                    <div class="chat-input-area">
                        <input type="text" class="chat-input" id="chatInput" placeholder="ËæìÂÖ•Ê∂àÊÅØ..." maxlength="100">
                        <button class="chat-send" onclick="sendChat()">ÂèëÈÄÅ</button>
                    </div>
                </div>
            </div>
            
            <!-- Êìç‰ΩúÊåâÈíÆ -->
            <div class="panel-section">
                <div class="section-title">üéõÔ∏è Êìç‰Ωú</div>
                <button class="btn btn-secondary" onclick="copyGameLink()">üìã Â§çÂà∂ÂØπÂ±ÄÈìæÊé•</button>
                <button class="btn btn-secondary" id="undoBtn" onclick="requestUndo()" disabled>‚Ü©Ô∏è ËØ∑Ê±ÇÊÇîÊ£ã</button>
                <button class="btn btn-danger" onclick="resign()">üè≥Ô∏è ËÆ§Ëæì</button>
                <button class="btn btn-primary" onclick="resetGame()">üîÑ ÈáçÊñ∞ÂºÄÂßã</button>
            </div>
            
            <!-- ËÆæÁΩÆ -->
            <div class="panel-section">
                <div class="section-title">‚öôÔ∏è ËÆæÁΩÆ</div>
                <div class="settings-row">
                    <span>Ëµ∞Ê£ãÈü≥Êïà</span>
                    <div class="toggle active" id="soundToggle" onclick="toggleSound()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
            </div>
            
            <!-- Ëµ∞Ê£ãËÆ∞ÂΩï -->
            <div class="panel-section">
                <div class="section-title">üìù Ëµ∞Ê£ãËÆ∞ÂΩï</div>
                <div class="moves-list" id="movesList">
                    <div style="color:#999;text-align:center;">ÊöÇÊó†Ëµ∞Ê£ãËÆ∞ÂΩï</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>

    <script>
        // ==================== ÈÖçÁΩÆ ====================
        const GIST_ID = '932c2d47035c60f134c28cce0b08428e';
        const GIST_API = `https://api.github.com/gists/${GIST_ID}`;
        const GITHUB_TOKEN = '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';
        
        // ==================== Ê∏∏ÊàèÁä∂ÊÄÅ ====================
        let gameState = {
            board: [],
            turn: 'red',
            lastMove: null,
            moveCount: 0,
            timestamp: Date.now(),
            players: { red: null, black: null },
            status: 'waiting',
            moves: [],
            chat: [],
            undoRequest: null,
            timers: { red: 600, black: 600 },
            timerRunning: false
        };
        
        let myColor = null;
        let selectedPiece = null;
        let myPlayerId = localStorage.getItem('chess_player_id') || generateId();
        let syncInterval = null;
        let isSyncing = false;
        let soundEnabled = true;
        let timerInterval = null;
        let lastTimerUpdate = Date.now();
        let isFirstLoad = true;
        
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        const pieceNames = {
            'R': 'ËΩ¶', 'N': 'È©¨', 'B': 'Ë±°', 'A': 'Â£´', 'K': 'Â∞Ü', 'C': 'ÁÇÆ', 'P': 'ÂÖµ',
            'r': 'ËΩ¶', 'n': 'È©¨', 'b': 'Áõ∏', 'a': '‰ªï', 'k': 'Â∏Ö', 'c': 'ÁÇÆ', 'p': 'Âçí'
        };
        
        // ==================== Èü≥Êïà ====================
        function playSound(type) {
            if (!soundEnabled) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'move':
                    oscillator.frequency.value = 400;
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'capture':
                    oscillator.frequency.value = 200;
                    gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                case 'check':
                    oscillator.frequency.value = 800;
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'win':
                    oscillator.frequency.value = 600;
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.5);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                case 'select':
                    oscillator.frequency.value = 600;
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.05);
                    break;
            }
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundToggle').classList.toggle('active');
            showToast(soundEnabled ? 'Èü≥ÊïàÂ∑≤ÂºÄÂêØ' : 'Èü≥ÊïàÂ∑≤ÂÖ≥Èó≠');
        }
        
        // ==================== ÂàùÂßãÂåñ ====================
        function init() {
            localStorage.setItem('chess_player_id', myPlayerId);
            drawBoard();
            initBoard(false); // ÂÖàÂàùÂßãÂåñÊú¨Âú∞Ê£ãÁõò
            loadGame();
            startSync();
            startTimer();
            setupChatInput();
            updateRoleButtons();
        }
        
        function generateId() {
            return 'player_' + Math.random().toString(36).substr(2, 9);
        }
        
        function setupChatInput() {
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendChat();
            });
        }
        
        // ==================== ÈòµËê•ÈÄâÊã©Ôºà‰øÆÂ§çÁâàÔºâ====================
        function selectRole(color) {
            if (myColor) {
                showToast('‰Ω†Â∑≤ÁªèÈÄâÊã©‰∫ÜÈòµËê•ÔºÅ');
                return;
            }
            
            // Ê£ÄÊü•ÂØπÊñπÊòØÂê¶Â∑≤ÈÄâ
            if (gameState.players[color]) {
                showToast('ËØ•ÈòµËê•Â∑≤Ë¢´ÈÄâÊã©ÔºåËØ∑ÈÄâÊã©Âè¶‰∏Ä‰∏™ÔºÅ');
                return;
            }
            
            myColor = color;
            gameState.players[color] = myPlayerId;
            
            // Êõ¥Êñ∞UI
            const badge = document.getElementById('playerRole');
            badge.textContent = color === 'red' ? 'Á∫¢Êñπ' : 'ÈªëÊñπ';
            badge.className = `player-badge ${color}`;
            
            document.getElementById('roleSelection').style.display = 'none';
            
            // Ê∑ªÂä†Á≥ªÁªüÊ∂àÊÅØ
            gameState.chat.push({
                sender: 'system',
                text: `${color === 'red' ? 'Á∫¢Êñπ' : 'ÈªëÊñπ'}Â∑≤Âä†ÂÖ•Ê∏∏Êàè`,
                time: Date.now()
            });
            
            // Â¶ÇÊûúÂèåÊñπÈÉΩÂä†ÂÖ•‰∫ÜÔºåÂºÄÂßãÊ∏∏Êàè
            if (gameState.players.red && gameState.players.black) {
                gameState.status = 'playing';
                gameState.timerRunning = true;
                gameState.chat.push({
                    sender: 'system',
                    text: 'Ê∏∏ÊàèÂºÄÂßãÔºÅÁ∫¢ÊñπÂÖàË°å',
                    time: Date.now()
                });
            }
            
            playSound('select');
            renderChat();
            updateRoleButtons();
            saveGame();
            showToast(`‰Ω†ÊòØ${color === 'red' ? 'Á∫¢Êñπ' : 'ÈªëÊñπ'}ÔºÅ`);
        }
        
        function updateRoleButtons() {
            const btnRed = document.getElementById('btnRed');
            const btnBlack = document.getElementById('btnBlack');
            
            // ÈáçÁΩÆÊåâÈíÆÁä∂ÊÄÅ
            btnRed.className = 'role-btn red';
            btnBlack.className = 'role-btn black';
            
            // Ê†áËÆ∞Â∑≤ÈÄâÊã©ÁöÑÈòµËê•
            if (gameState.players.red) {
                btnRed.classList.add('disabled');
                if (gameState.players.red === myPlayerId) btnRed.classList.add('selected');
            }
            if (gameState.players.black) {
                btnBlack.classList.add('disabled');
                if (gameState.players.black === myPlayerId) btnBlack.classList.add('selected');
            }
            
            // Â¶ÇÊûúÂ∑≤ÁªèÈÄâ‰∫ÜÈòµËê•ÔºåÈöêËóèÈÄâÊã©Âå∫
            if (myColor) {
                document.getElementById('roleSelection').style.display = 'none';
            }
        }
        
        // ==================== ËÆ°Êó∂Âô® ====================
        function startTimer() {
            timerInterval = setInterval(() => {
                if (gameState.status !== 'playing' || !gameState.timerRunning) return;
                
                const now = Date.now();
                const delta = Math.floor((now - lastTimerUpdate) / 1000);
                
                if (delta >= 1) {
                    if (gameState.turn === 'red') {
                        gameState.timers.red = Math.max(0, gameState.timers.red - delta);
                    } else {
                        gameState.timers.black = Math.max(0, gameState.timers.black - delta);
                    }
                    
                    if (gameState.timers.red === 0 || gameState.timers.black === 0) {
                        const winner = gameState.timers.red === 0 ? 'ÈªëÊñπ' : 'Á∫¢Êñπ';
                        showToast(`‚è∞ Êó∂Èó¥Âà∞ÔºÅ${winner}Ëé∑ËÉúÔºÅ`);
                        gameState.status = 'finished';
                        playSound('win');
                    }
                    
                    updateTimerDisplay();
                    lastTimerUpdate = now;
                }
            }, 1000);
        }
        
        function updateTimerDisplay() {
            document.getElementById('timeRed').textContent = formatTime(gameState.timers.red);
            document.getElementById('timeBlack').textContent = formatTime(gameState.timers.black);
            
            document.getElementById('timerRed').classList.toggle('active', 
                gameState.turn === 'red' && gameState.status === 'playing');
            document.getElementById('timerBlack').classList.toggle('active', 
                gameState.turn === 'black' && gameState.status === 'playing');
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        // ==================== ËÅäÂ§© ====================
        function sendChat() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (!message) return;
            
            if (!myColor) {
                showToast('ËØ∑ÂÖàÈÄâÊã©ÈòµËê•');
                return;
            }
            
            const chatMessage = {
                sender: myColor,
                playerId: myPlayerId,
                text: message,
                time: Date.now()
            };
            
            gameState.chat.push(chatMessage);
            input.value = '';
            
            renderChat();
            saveGame();
        }
        
        function renderChat() {
            const container = document.getElementById('chatMessages');
            container.innerHTML = '';
            
            gameState.chat.slice(-50).forEach(msg => {
                const div = document.createElement('div');
                div.className = 'chat-message';
                
                if (msg.sender === 'system') {
                    div.className += ' system';
                    div.textContent = msg.text;
                } else {
                    const isOwn = msg.playerId === myPlayerId;
                    div.className += isOwn ? ' own' : ' other';
                    
                    const sender = document.createElement('div');
                    sender.className = 'chat-sender';
                    sender.textContent = msg.sender === 'red' ? 'Á∫¢Êñπ' : 'ÈªëÊñπ';
                    div.appendChild(sender);
                    
                    const text = document.createElement('div');
                    text.textContent = msg.text;
                    div.appendChild(text);
                }
                
                container.appendChild(div);
            });
            
            container.scrollTop = container.scrollHeight;
        }
        
        // ==================== ÊÇîÊ£ã ====================
        function requestUndo() {
            if (!myColor || gameState.moves.length === 0) {
                showToast('Áé∞Âú®‰∏çËÉΩÊÇîÊ£ã');
                return;
            }
            
            if (gameState.undoRequest) {
                showToast('Â∑≤ÁªèÊúâ‰∏Ä‰∏™ÊÇîÊ£ãËØ∑Ê±Ç‰∫Ü');
                return;
            }
            
            gameState.undoRequest = {
                requester: myColor,
                moveCount: gameState.moveCount,
                timestamp: Date.now()
            };
            
            saveGame();
            showToast('Â∑≤ÂèëÈÄÅÊÇîÊ£ãËØ∑Ê±ÇÔºåÁ≠âÂæÖÂØπÊñπÂêåÊÑè');
            checkUndoRequest();
        }
        
        function checkUndoRequest() {
            const area = document.getElementById('undoRequestArea');
            
            if (!gameState.undoRequest) {
                area.style.display = 'none';
                area.innerHTML = '';
                return;
            }
            
            const isRequester = gameState.undoRequest.requester === myColor;
            
            if (isRequester) {
                area.style.display = 'block';
                area.innerHTML = '<div style="color:#856404;">Á≠âÂæÖÂØπÊñπÂêåÊÑèÊÇîÊ£ã...</div>';
            } else {
                area.style.display = 'block';
                area.innerHTML = `
                    <div class="undo-request">
                        <div>ÂØπÊñπËØ∑Ê±ÇÊÇîÊ£ãÔºàÂõûÂà∞Á¨¨${gameState.undoRequest.moveCount}Ê≠•Ôºâ</div>
                        <div class="undo-buttons">
                            <button class="btn btn-primary" onclick="acceptUndo()">ÂêåÊÑè</button>
                            <button class="btn btn-secondary" onclick="rejectUndo()">ÊãíÁªù</button>
                        </div>
                    </div>
                `;
            }
        }
        
        function acceptUndo() {
            const targetMove = gameState.undoRequest.moveCount;
            
            // ÈáçÊñ∞ÂàùÂßãÂåñÊ£ãÁõò
            initBoard(false);
            
            gameState.undoRequest = null;
            gameState.chat.push({
                sender: 'system',
                text: `ÊÇîÊ£ãÊàêÂäüÔºåÂõûÈÄÄÂà∞Á¨¨${targetMove}Ê≠•`,
                time: Date.now()
            });
            
            saveGame();
            showToast('Â∑≤ÂêåÊÑèÊÇîÊ£ã');
            renderChat();
        }
        
        function rejectUndo() {
            gameState.undoRequest = null;
            gameState.chat.push({
                sender: 'system',
                text: 'ÊÇîÊ£ãËØ∑Ê±ÇË¢´ÊãíÁªù',
                time: Date.now()
            });
            saveGame();
            showToast('Â∑≤ÊãíÁªùÊÇîÊ£ãËØ∑Ê±Ç');
            renderChat();
        }
        
        // ==================== ÁªòÂà∂Ê£ãÁõò ====================
        function drawBoard() {
            const hLines = document.getElementById('hLines');
            const vLines = document.getElementById('vLines');
            
            for (let i = 0; i < 10; i++) {
                const line = document.createElement('div');
                line.className = 'horizontal-line';
                line.style.top = `${i * 50 + 25}px`;
                hLines.appendChild(line);
            }
            
            for (let i = 0; i < 9; i++) {
                const line = document.createElement('div');
                line.className = 'vertical-line';
                line.style.left = `${i * 50 + 25}px`;
                
                if (i === 0 || i === 8) {
                    line.style.height = '100%';
                } else {
                    line.style.height = '200px';
                    line.style.top = '25px';
                    
                    const line2 = document.createElement('div');
                    line2.className = 'vertical-line';
                    line2.style.left = `${i * 50 + 25}px`;
                    line2.style.height = '200px';
                    line2.style.top = '275px';
                    vLines.appendChild(line2);
                }
                vLines.appendChild(line);
            }
        }
        
        // ==================== Ê£ãÂ≠êÊìç‰Ωú ====================
        function renderPieces() {
            const container = document.getElementById('piecesContainer');
            container.innerHTML = '';
            
            if (!gameState.board || gameState.board.length === 0) {
                console.log('Ê£ãÁõòÊú™ÂàùÂßãÂåñ');
                return;
            }
            
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece !== '.') {
                        const el = document.createElement('div');
                        el.className = `piece ${piece === piece.toUpperCase() ? 'black' : 'red'}`;
                        el.textContent = pieceNames[piece];
                        el.style.left = `${col * 50 + 3}px`;
                        el.style.top = `${row * 50 + 3}px`;
                        
                        if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                            el.classList.add('selected');
                        }
                        
                        if (gameState.lastMove) {
                            const [from, to] = [gameState.lastMove.from, gameState.lastMove.to];
                            if ((row === from.row && col === from.col) || 
                                (row === to.row && col === to.col)) {
                                el.classList.add('last-move');
                            }
                        }
                        
                        if (piece.toUpperCase() === 'K' && isInCheck(piece === piece.toLowerCase())) {
                            el.classList.add('check');
                        }
                        
                        el.onclick = () => onPieceClick(row, col);
                        container.appendChild(el);
                    }
                }
            }
            
            if (selectedPiece) {
                showMoveHints(selectedPiece.row, selectedPiece.col);
            }
        }
        
        function showMoveHints(row, col) {
            const container = document.getElementById('piecesContainer');
            const piece = gameState.board[row][col];
            if (!piece || piece === '.') return;
            
            const isRed = piece === piece.toLowerCase();
            if ((isRed && myColor !== 'red') || (!isRed && myColor !== 'black')) return;
            if ((isRed && gameState.turn !== 'red') || (!isRed && gameState.turn !== 'black')) return;
            
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const hint = document.createElement('div');
                        hint.className = 'move-hint';
                        hint.style.left = `${c * 50 + 25}px`;
                        hint.style.top = `${r * 50 + 25}px`;
                        hint.onclick = () => onHintClick(r, c);
                        container.appendChild(hint);
                    }
                }
            }
        }
        
        function onPieceClick(row, col) {
            // ÂøÖÈ°ªÂÖàÈÄâÈòµËê•
            if (!myColor) {
                showToast('ËØ∑ÂÖàÈÄâÊã©ÈòµËê•ÔºÅ');
                return;
            }
            
            // ÂøÖÈ°ªËΩÆÂà∞Â∑±Êñπ
            if (gameState.turn !== myColor) {
                showToast('ËøòÊ≤°ËΩÆÂà∞‰Ω†ÔºÅ');
                return;
            }
            
            const piece = gameState.board[row][col];
            if (!piece || piece === '.') return;
            
            const isRed = piece === piece.toLowerCase();
            
            // Âè™ËÉΩÈÄâËá™Â∑±ÁöÑÊ£ãÂ≠ê
            if ((isRed && myColor !== 'red') || (!isRed && myColor !== 'black')) {
                showToast('ËøôÊòØÂØπÊñπÁöÑÊ£ãÂ≠êÔºÅ');
                return;
            }
            
            playSound('select');
            
            if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                selectedPiece = null;
            } else {
                selectedPiece = { row, col, piece };
            }
            renderPieces();
        }
        
        function onHintClick(row, col) {
            if (!selectedPiece) return;
            makeMove(selectedPiece.row, selectedPiece.col, row, col);
            selectedPiece = null;
        }
        
        // ==================== Ëµ∞Ê£ãÈÄªËæë ====================
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (toRow < 0 || toRow > 9 || toCol < 0 || toCol > 8) return false;
            if (fromRow === toRow && fromCol === toCol) return false;
            
            const piece = gameState.board[fromRow][fromCol];
            const target = gameState.board[toRow][toCol];
            
            if (target !== '.' && target !== '') {
                const isRedPiece = piece === piece.toLowerCase();
                const isRedTarget = target === target.toLowerCase();
                if (isRedPiece === isRedTarget) return false;
            }
            
            const type = piece.toUpperCase();
            const isRed = piece === piece.toLowerCase();
            
            switch(type) {
                case 'R': return validateRook(fromRow, fromCol, toRow, toCol);
                case 'N': return validateKnight(fromRow, fromCol, toRow, toCol);
                case 'B': return validateBishop(fromRow, fromCol, toRow, toCol, isRed);
                case 'A': return validateAdvisor(fromRow, fromCol, toRow, toCol, isRed);
                case 'K': return validateKing(fromRow, fromCol, toRow, toCol, isRed);
                case 'C': return validateCannon(fromRow, fromCol, toRow, toCol);
                case 'P': return validatePawn(fromRow, fromCol, toRow, toCol, isRed);
                default: return false;
            }
        }
        
        function countPiecesBetween(r1, c1, r2, c2) {
            let count = 0;
            if (r1 === r2) {
                const min = Math.min(c1, c2);
                const max = Math.max(c1, c2);
                for (let c = min + 1; c < max; c++) {
                    if (gameState.board[r1][c] !== '.' && gameState.board[r1][c] !== '') count++;
                }
            } else if (c1 === c2) {
                const min = Math.min(r1, r2);
                const max = Math.max(r1, r2);
                for (let r = min + 1; r < max; r++) {
                    if (gameState.board[r][c1] !== '.' && gameState.board[r][c1] !== '') count++;
                }
            }
            return count;
        }
        
        function validateRook(r1, c1, r2, c2) {
            if (r1 !== r2 && c1 !== c2) return false;
            return countPiecesBetween(r1, c1, r2, c2) === 0;
        }
        
        function validateKnight(r1, c1, r2, c2) {
            const dr = Math.abs(r2 - r1);
            const dc = Math.abs(c2 - c1);
            if (!((dr === 2 && dc === 1) || (dr === 1 && dc === 2))) return false;
            
            if (dr === 2) {
                const blockR = r1 + (r2 > r1 ? 1 : -1);
                if (gameState.board[blockR][c1] !== '.' && gameState.board[blockR][c1] !== '') return false;
            } else {
                const blockC = c1 + (c2 > c1 ? 1 : -1);
                if (gameState.board[r1][blockC] !== '.' && gameState.board[r1][blockC] !== '') return false;
            }
            return true;
        }
        
        function validateBishop(r1, c1, r2, c2, isRed) {
            const dr = Math.abs(r2 - r1);
            const dc = Math.abs(c2 - c1);
            if (dr !== 2 || dc !== 2) return false;
            
            if (isRed && r2 < 5) return false;
            if (!isRed && r2 > 4) return false;
            
            const eyeR = (r1 + r2) / 2;
            const eyeC = (c1 + c2) / 2;
            if (gameState.board[eyeR][eyeC] !== '.' && gameState.board[eyeR][eyeC] !== '') return false;
            
            return true;
        }
        
        function validateAdvisor(r1, c1, r2, c2, isRed) {
            const dr = Math.abs(r2 - r1);
            const dc = Math.abs(c2 - c1);
            if (dr !== 1 || dc !== 1) return false;
            
            if (c2 < 3 || c2 > 5) return false;
            if (isRed && r2 < 7) return false;
            if (!isRed && r2 > 2) return false;
            
            return true;
        }
        
        function validateKing(r1, c1, r2, c2, isRed) {
            const dr = Math.abs(r2 - r1);
            const dc = Math.abs(c2 - c1);
            
            if (c1 === c2) {
                let hasPiece = false;
                const min = Math.min(r1, r2);
                const max = Math.max(r1, r2);
                for (let r = min + 1; r < max; r++) {
                    if (gameState.board[r][c1] !== '.' && gameState.board[r][c1] !== '') {
                        hasPiece = true;
                        break;
                    }
                }
                if (!hasPiece) {
                    const target = gameState.board[r2][c2];
                    if (target && (target.toUpperCase() === 'K')) return true;
                }
            }
            
            if (dr + dc !== 1) return false;
            
            if (c2 < 3 || c2 > 5) return false;
            if (isRed && r2 < 7) return false;
            if (!isRed && r2 > 2) return false;
            
            return true;
        }
        
        function validateCannon(r1, c1, r2, c2) {
            if (r1 !== r2 && c1 !== c2) return false;
            
            const count = countPiecesBetween(r1, c1, r2, c2);
            const target = gameState.board[r2][c2];
            
            if (target === '.' || target === '') {
                return count === 0;
            } else {
                return count === 1;
            }
        }
        
        function validatePawn(r1, c1, r2, c2, isRed) {
            const dr = r2 - r1;
            const dc = Math.abs(c2 - c1);
            
            if (isRed) {
                if (dr > 0) return false;
                if (r1 >= 5 && dc !== 0) return false;
                if (dr === -1 && dc === 0) return true;
                if (r1 < 5 && dr === 0 && dc === 1) return true;
            } else {
                if (dr < 0) return false;
                if (r1 <= 4 && dc !== 0) return false;
                if (dr === 1 && dc === 0) return true;
                if (r1 > 4 && dr === 0 && dc === 1) return true;
            }
            return false;
        }
        
        // ==================== Â∞ÜÂÜõÊ£ÄÊµã ====================
        function isInCheck(isRed) {
            let kingRow, kingCol;
            const kingChar = isRed ? 'k' : 'K';
            
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    if (gameState.board[r][c] === kingChar) {
                        kingRow = r;
                        kingCol = c;
                        break;
                    }
                }
            }
            
            if (kingRow === undefined) return false;
            
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    const piece = gameState.board[r][c];
                    if (piece !== '.' && piece !== '') {
                        const pieceIsRed = piece === piece.toLowerCase();
                        if (pieceIsRed !== isRed) {
                            if (isValidMove(r, c, kingRow, kingCol)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
        
        // ==================== Ê∏∏ÊàèÊìç‰Ωú ====================
        async function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const target = gameState.board[toRow][toCol];
            const isCapture = target !== '.' && target !== '';
            
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = '.';
            
            const moveNotation = `${pieceNames[piece]} ${String.fromCharCode(97 + fromCol)}${9-fromRow}‚Üí${String.fromCharCode(97 + toCol)}${9-toRow}`;
            gameState.moves.push(moveNotation);
            
            gameState.lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };
            gameState.turn = gameState.turn === 'red' ? 'black' : 'red';
            gameState.moveCount++;
            gameState.timestamp = Date.now();
            gameState.timerRunning = true;
            lastTimerUpdate = Date.now();
            
            if (isCapture) {
                playSound('capture');
            } else {
                playSound('move');
            }
            
            const opponentIsRed = gameState.turn === 'red';
            if (isInCheck(opponentIsRed)) {
                playSound('check');
                showToast('Â∞ÜÂÜõÔºÅ');
            }
            
            if (target && target.toUpperCase() === 'K') {
                const winner = gameState.turn === 'red' ? 'ÈªëÊñπ' : 'Á∫¢Êñπ';
                showToast(`üéâ ${winner}Ëé∑ËÉúÔºÅ`);
                gameState.status = 'finished';
                gameState.timerRunning = false;
                playSound('win');
            }
            
            renderPieces();
            updateUI();
            await saveGame();
        }
        
        function updateUI() {
            document.getElementById('currentTurn').textContent = gameState.turn === 'red' ? 'Á∫¢Êñπ' : 'ÈªëÊñπ';
            document.getElementById('currentTurn').style.color = gameState.turn === 'red' ? '#c62828' : '#333';
            
            updateTimerDisplay();
            
            const movesList = document.getElementById('movesList');
            if (gameState.moves.length === 0) {
                movesList.innerHTML = '<div style="color:#999;text-align:center;">ÊöÇÊó†Ëµ∞Ê£ãËÆ∞ÂΩï</div>';
            } else {
                movesList.innerHTML = gameState.moves.map((m, i) => {
                    const isRed = i % 2 === 0;
                    return `<div class="move-item">
                        <span class="move-number">${Math.floor(i/2)+1}.</span>
                        <span class="${isRed ? 'move-red' : 'move-black'}">${m}</span>
                    </div>`;
                }).join('');
                movesList.scrollTop = movesList.scrollHeight;
            }
            
            document.getElementById('undoBtn').disabled = 
                !myColor || gameState.moves.length === 0 || gameState.status === 'finished';
        }
        
        // ==================== Êï∞ÊçÆÂêåÊ≠•Ôºà‰øÆÂ§çÁâàÔºâ====================
        async function loadGame() {
            try {
                const response = await fetch(GIST_API, {
                    headers: {
                        'Authorization': `token ${GITHUB_TOKEN}`
                    }
                });
                if (!response.ok) throw new Error('Failed to load');
                
                const gist = await response.json();
                const content = gist.files['chess-game.json'].content;
                const data = JSON.parse(content);
                
                // ÂêàÂπ∂Êï∞ÊçÆÔºö‰øùÁïôÊú¨Âú∞ÈÄâÊã©ÔºåÂêåÊ≠•Ê∏∏ÊàèÁä∂ÊÄÅ
                if (data.timestamp > gameState.timestamp || isFirstLoad) {
                    isFirstLoad = false;
                    
                    // ‰øùÂ≠òÊú¨Âú∞ÈòµËê•ÈÄâÊã©
                    const localColor = myColor;
                    const localPlayerId = myPlayerId;
                    
                    // ÂêåÊ≠•Ê∏∏ÊàèÊï∞ÊçÆ
                    gameState = data;
                    
                    // ÊÅ¢Â§çÊú¨Âú∞Ë∫´‰ªΩ
                    myPlayerId = localPlayerId;
                    if (localColor) {
                        myColor = localColor;
                        // Á°Æ‰øùÊúçÂä°Âô®ËÆ∞ÂΩïÊ≠£Á°Æ
                        if (gameState.players[localColor] !== localPlayerId) {
                            gameState.players[localColor] = localPlayerId;
                        }
                    }
                    
                    // Ê£ÄÊü•Âπ∂Êõ¥Êñ∞ÈòµËê•Áä∂ÊÄÅ
                    if (gameState.players.red === myPlayerId) myColor = 'red';
                    else if (gameState.players.black === myPlayerId) myColor = 'black';
                    
                    renderPieces();
                    updateUI();
                    renderChat();
                    checkUndoRequest();
                    updateRoleButtons();
                }
                
                updateConnectionStatus(true);
            } catch (err) {
                console.error('Load error:', err);
                updateConnectionStatus(false);
                if (gameState.board.length === 0) {
                    initBoard(false);
                }
            }
        }
        
        async function saveGame() {
            if (isSyncing) return;
            isSyncing = true;
            updateConnectionStatus(true, true);
            
            try {
                const response = await fetch(GIST_API, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/vnd.github.v3+json',
                        'Authorization': `token ${GITHUB_TOKEN}`
                    },
                    body: JSON.stringify({
                        files: {
                            'chess-game.json': {
                                content: JSON.stringify(gameState, null, 2)
                            }
                        }
                    })
                });
                
                if (!response.ok) throw new Error('Failed to save');
                
                updateConnectionStatus(true);
            } catch (err) {
                console.error('Save error:', err);
                showToast('‰øùÂ≠òÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªú');
                updateConnectionStatus(false);
            } finally {
                isSyncing = false;
            }
        }
        
        function startSync() {
            syncInterval = setInterval(loadGame, 2000);
        }
        
        function updateConnectionStatus(connected, syncing = false) {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            
            if (syncing) {
                dot.className = 'status-dot syncing';
                text.textContent = 'ÂêåÊ≠•‰∏≠...';
            } else if (connected) {
                dot.className = 'status-dot connected';
                text.textContent = 'Â∑≤ËøûÊé•';
            } else {
                dot.className = 'status-dot';
                text.textContent = 'Êú™ËøûÊé•';
            }
        }
        
        // ==================== ÂàùÂßãÂåñÊ£ãÁõò ====================
        function initBoard(save = true) {
            gameState.board = [
                ['R','N','B','A','K','A','B','N','R'],
                ['.','.','.','.','.','.','.','.','.'],
                ['.','C','.','.','.','.','.','C','.'],
                ['P','.','P','.','P','.','P','.','P'],
                ['.','.','.','.','.','.','.','.','.'],
                ['.','.','.','.','.','.','.','.','.'],
                ['p','.','p','.','p','.','p','.','p'],
                ['.','c','.','.','.','.','.','c','.'],
                ['.','.','.','.','.','.','.','.','.'],
                ['r','n','b','a','k','a','b','n','r']
            ];
            gameState.turn = 'red';
            gameState.lastMove = null;
            gameState.moveCount = 0;
            gameState.moves = [];
            gameState.status = 'waiting';
            gameState.timers = { red: 600, black: 600 };
            gameState.timerRunning = false;
            gameState.undoRequest = null;
            gameState.timestamp = Date.now();
            
            if (!gameState.chat) gameState.chat = [];
            
            renderPieces();
            updateUI();
            renderChat();
            checkUndoRequest();
            
            if (save) saveGame();
        }
        
        // ==================== ÊåâÈíÆÂäüËÉΩ ====================
        function copyGameLink() {
            const url = window.location.href;
            navigator.clipboard.writeText(url).then(() => {
                showToast('ÈìæÊé•Â∑≤Â§çÂà∂ÔºåÂàÜ‰∫´ÁªôÂß•Áà∑ÂêßÔºÅ');
            });
        }
        
        function resign() {
            if (!confirm('Á°ÆÂÆöË¶ÅËÆ§ËæìÂêóÔºü')) return;
            
            const winner = myColor === 'red' ? 'ÈªëÊñπ' : 'Á∫¢Êñπ';
            showToast(`‰Ω†ËÆ§Ëæì‰∫ÜÔºå${winner}Ëé∑ËÉúÔºÅ`);
            gameState.status = 'finished';
            gameState.timerRunning = false;
            
            gameState.chat.push({
                sender: 'system',
                text: `${myColor === 'red' ? 'Á∫¢Êñπ' : 'ÈªëÊñπ'}ËÆ§ËæìÔºå${winner}Ëé∑ËÉúÔºÅ`,
                time: Date.now()
            });
            
            playSound('win');
            saveGame();
            renderChat();
        }
        
        async function resetGame() {
            if (!confirm('Á°ÆÂÆöË¶ÅÈáçÊñ∞ÂºÄÂßãÂêóÔºü')) return;
            
            // ‰øùÁïôÈòµËê•ÈÄâÊã©ÔºåÈáçÁΩÆÊ∏∏ÊàèÁä∂ÊÄÅ
            const savedRed = gameState.players.red;
            const savedBlack = gameState.players.black;
            
            initBoard(false);
            
            gameState.players.red = savedRed;
            gameState.players.black = savedBlack;
            
            if (savedRed && savedBlack) {
                gameState.status = 'playing';
                gameState.timerRunning = true;
            }
            
            gameState.chat.push({
                sender: 'system',
                text: 'Ê∏∏ÊàèÂ∑≤ÈáçÁΩÆÔºÅ',
                time: Date.now()
            });
            
            await saveGame();
            showToast('Ê∏∏ÊàèÂ∑≤ÈáçÁΩÆÔºÅ');
            renderChat();
        }
        
        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }
        
        // ==================== ÂêØÂä® ====================
        window.onload = init;
    </script>
</body>
</html>
