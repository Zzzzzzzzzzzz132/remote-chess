<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿œç¨‹è±¡æ£‹ - ä¸å§¥çˆ·å¯¹å¼ˆ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: "Microsoft YaHei", "SimSun", sans-serif;
            background: linear-gradient(135deg, #f5f5dc 0%, #e8dcc0 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .header { text-align: center; margin-bottom: 20px; }
        h1 { color: #8b4513; font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.1); margin-bottom: 10px; }
        .subtitle { color: #666; font-size: 1.1em; }
        .game-container {
            display: flex; gap: 30px; align-items: flex-start; flex-wrap: wrap;
            justify-content: center; max-width: 1200px; width: 100%;
        }
        .board-wrapper {
            position: relative; background: #f0d9b5; padding: 40px;
            border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 3px solid #8b4513;
        }
        .board { width: 450px; height: 500px; position: relative; background: #f0d9b5; }
        .board-lines { position: absolute; width: 100%; height: 100%; }
        .horizontal-lines, .vertical-lines { position: absolute; width: 100%; height: 100%; }
        .horizontal-line { position: absolute; width: 400px; height: 1px; background: #333; left: 25px; }
        .vertical-line { position: absolute; width: 1px; background: #333; }
        .palace-lines { position: absolute; width: 100%; height: 100%; pointer-events: none; }
        .palace-line { position: absolute; width: 141px; height: 1px; background: #333; transform-origin: left center; }
        .palace-line.top-left { top: 75px; left: 154px; transform: rotate(45deg); }
        .palace-line.top-right { top: 75px; right: 154px; transform: rotate(-45deg); }
        .palace-line.bottom-left { bottom: 75px; left: 154px; transform: rotate(-45deg); }
        .palace-line.bottom-right { bottom: 75px; right: 154px; transform: rotate(45deg); }
        .river {
            position: absolute; top: 225px; left: 0; width: 100%; height: 50px;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; color: #8b4513; font-weight: bold; letter-spacing: 20px;
        }
        .pieces-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .piece {
            position: absolute; width: 44px; height: 44px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; font-weight: bold; cursor: pointer;
            transition: all 0.3s ease; user-select: none; z-index: 10;
        }
        .piece.red {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #cc0000);
            color: #ffeb3b; border: 2px solid #8b0000; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .piece.black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            color: #fff; border: 2px solid #333; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .piece:hover { transform: scale(1.1); box-shadow: 0 0 15px rgba(255,215,0,0.8); }
        .piece.selected { box-shadow: 0 0 20px #ffd700, 0 0 40px #ffd700; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1.1); } 50% { transform: scale(1.2); } }
        .piece.last-move { border: 3px solid #00ff00; }
        .piece.check { animation: check-pulse 0.5s infinite; box-shadow: 0 0 20px #ff0000; }
        @keyframes check-pulse { 0%, 100% { box-shadow: 0 0 20px #ff0000; } 50% { box-shadow: 0 0 40px #ff0000, 0 0 60px #ff0000; } }
        .move-hint {
            position: absolute; width: 16px; height: 16px; background: rgba(0,255,0,0.6);
            border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: auto; cursor: pointer; z-index: 5;
        }
        .move-hint:hover { background: rgba(0,255,0,0.9); transform: translate(-50%, -50%) scale(1.3); }
        .side-panel { display: flex; flex-direction: column; gap: 20px; width: 320px; }
        .panel-section {
            background: white; padding: 20px; border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1); border: 2px solid #8b4513;
        }
        .section-title { font-weight: bold; color: #8b4513; margin-bottom: 15px; font-size: 1.1em; display: flex; align-items: center; gap: 8px; }
        .timer-box { display: flex; justify-content: space-around; margin-bottom: 15px; }
        .timer { text-align: center; padding: 10px; border-radius: 8px; background: #f5f5f5; min-width: 80px; }
        .timer.active { background: #e3f2fd; border: 2px solid #2196f3; }
        .timer-label { font-size: 0.8em; color: #666; margin-bottom: 5px; }
        .timer-time { font-size: 1.5em; font-weight: bold; font-family: monospace; }
        .timer.red .timer-time { color: #c62828; }
        .timer.black .timer-time { color: #333; }
        .status-content { color: #333; line-height: 1.6; }
        .player-badge { display: inline-block; padding: 4px 12px; border-radius: 15px; font-size: 0.9em; font-weight: bold; margin-top: 5px; }
        .player-badge.red { background: #ffeb3b; color: #c62828; }
        .player-badge.black { background: #333; color: #fff; }
        .btn { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; transition: all 0.3s; font-family: inherit; }
        .btn-primary { background: #8b4513; color: white; }
        .btn-primary:hover { background: #6b3410; transform: translateY(-2px); }
        .btn-secondary { background: #e0e0e0; color: #333; }
        .btn-secondary:hover { background: #d0d0d0; }
        .btn-danger { background: #c62828; color: white; }
        .btn-danger:hover { background: #a02020; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .chat-container { display: flex; flex-direction: column; height: 250px; }
        .chat-messages { flex: 1; overflow-y: auto; background: #f9f9f9; border-radius: 6px; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; }
        .chat-message { margin-bottom: 8px; padding: 6px 10px; border-radius: 12px; max-width: 85%; word-wrap: break-word; font-size: 0.9em; }
        .chat-message.own { background: #dcf8c6; margin-left: auto; text-align: right; }
        .chat-message.other { background: #fff; border: 1px solid #e0e0e0; }
        .chat-message.system { background: #fff3cd; text-align: center; font-size: 0.8em; color: #856404; max-width: 100%; }
        .chat-sender { font-size: 0.75em; color: #666; margin-bottom: 2px; }
        .chat-input-area { display: flex; gap: 8px; }
        .chat-input { flex: 1; padding: 8px 12px; border: 1px solid #ddd; border-radius: 20px; outline: none; font-family: inherit; }
        .chat-send { padding: 8px 16px; background: #8b4513; color: white; border: none; border-radius: 20px; cursor: pointer; font-size: 0.9em; }
        .chat-send:hover { background: #6b3410; }
        .moves-list { max-height: 150px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 6px; font-size: 0.9em; }
        .move-item { padding: 4px 0; border-bottom: 1px solid #eee; color: #555; display: flex; justify-content: space-between; }
        .move-number { color: #999; min-width: 30px; }
        .move-red { color: #c62828; }
        .move-black { color: #333; }
        .undo-request { background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; padding: 15px; margin: 10px 0; text-align: center; }
        .undo-buttons { display: flex; gap: 10px; margin-top: 10px; }
        .undo-buttons .btn { margin: 0; flex: 1; padding: 8px; font-size: 14px; }
        .connection-status { display: inline-flex; align-items: center; gap: 5px; font-size: 0.85em; margin-top: 10px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #ccc; }
        .status-dot.connected { background: #4caf50; animation: blink 2s infinite; }
        .status-dot.syncing { background: #ff9800; animation: blink 0.5s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .settings-row { display: flex; align-items: center; justify-content: space-between; margin: 10px 0; }
        .toggle { position: relative; width: 50px; height: 26px; background: #ccc; border-radius: 13px; cursor: pointer; transition: background 0.3s; }
        .toggle.active { background: #4caf50; }
        .toggle-slider { position: absolute; top: 3px; left: 3px; width: 20px; height: 20px; background: white; border-radius: 50%; transition: transform 0.3s; }
        .toggle.active .toggle-slider { transform: translateX(24px); }
        .toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 12px 24px; border-radius: 25px; z-index: 1000; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        .toast.show { opacity: 1; }
        .role-selector { display: flex; gap: 10px; margin: 15px 0; }
        .role-btn { flex: 1; padding: 15px; border: 2px solid #ddd; border-radius: 8px; background: white; cursor: pointer; transition: all 0.3s; text-align: center; }
        .role-btn:hover { border-color: #8b4513; background: #f5f5f5; }
        .role-btn.selected { border-color: #8b4513; background: #e8dcc0; }
        .role-btn.disabled { opacity: 0.5; cursor: not-allowed; background: #f0f0f0; }
        .role-btn.red { border-color: #c62828; }
        .role-btn.black { border-color: #333; }
        .proxy-warning { background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; padding: 10px; margin-bottom: 15px; font-size: 0.85em; color: #856404; text-align: center; }
        @media (max-width: 800px) { .board { width: 360px; height: 400px; } .piece { width: 36px; height: 36px; font-size: 16px; } .side-panel { width: 100%; } }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ® è¿œç¨‹è±¡æ£‹ ğŸ®</h1>
        <p class="subtitle">ä¸å§¥çˆ·éš”ç©ºå¯¹å¼ˆï¼Œè·¨è¶Šä¸‡é‡Œçš„äº²æƒ…</p>
    </div>
    
    <div class="game-container">
        <div class="board-wrapper">
            <div class="board" id="board">
                <div class="board-lines">
                    <div class="horizontal-lines" id="hLines"></div>
                    <div class="vertical-lines" id="vLines"></div>
                    <div class="palace-lines">
                        <div class="palace-line top-left"></div>
                        <div class="palace-line top-right"></div>
                        <div class="palace-line bottom-left"></div>
                        <div class="palace-line bottom-right"></div>
                    </div>
                </div>
                <div class="river">æ¥š æ²³ æ±‰ ç•Œ</div>
                <div class="pieces-container" id="piecesContainer"></div>
            </div>
        </div>
        
        <div class="side-panel">
            <div class="panel-section" id="proxySection">
                <div class="proxy-warning">
                    âš ï¸ é¦–æ¬¡ä½¿ç”¨éœ€è¦æ¿€æ´»ä»£ç†<br>
                    <a href="https://cors-anywhere.herokuapp.com/corsdemo" target="_blank" style="color:#856404;font-weight:bold;">
                        ç‚¹å‡»è¿™é‡Œæ¿€æ´»ä»£ç†ï¼ˆå…è´¹ï¼‰
                    </a>
                </div>
            </div>
            
            <div class="panel-section" id="roleSelection">
                <div class="section-title">ğŸ­ é€‰æ‹©é˜µè¥</div>
                <div class="role-selector">
                    <div class="role-btn red" id="btnRed" onclick="selectRole('red')">
                        <div style="font-size:2em;">ğŸ”´</div>
                        <div>çº¢æ–¹</div>
                        <div style="font-size:0.8em;color:#666;">å…ˆæ‰‹</div>
                    </div>
                    <div class="role-btn black" id="btnBlack" onclick="selectRole('black')">
                        <div style="font-size:2em;">âš«</div>
                        <div>é»‘æ–¹</div>
                        <div style="font-size:0.8em;color:#666;">åæ‰‹</div>
                    </div>
                </div>
                <div style="text-align:center;color:#666;font-size:0.9em;">å§¥çˆ·é€‰å¦ä¸€ä¸ªé¢œè‰²å³å¯</div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">â±ï¸ è®¡æ—¶å™¨</div>
                <div class="timer-box">
                    <div class="timer red" id="timerRed">
                        <div class="timer-label">çº¢æ–¹</div>
                        <div class="timer-time" id="timeRed">10:00</div>
                    </div>
                    <div class="timer black" id="timerBlack">
                        <div class="timer-label">é»‘æ–¹</div>
                        <div class="timer-time" id="timeBlack">10:00</div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸ® æ¸¸æˆçŠ¶æ€</div>
                <div class="status-content">
                    <div>å½“å‰å›åˆ: <span id="currentTurn" style="font-weight:bold;">çº¢æ–¹</span></div>
                    <div>ä½ æ˜¯: <span id="playerRole" class="player-badge">æœªé€‰æ‹©</span></div>
                    <div class="connection-status">
                        <span class="status-dot" id="statusDot"></span>
                        <span id="statusText">è¿æ¥ä¸­...</span>
                    </div>
                </div>
                <div id="undoRequestArea" style="display:none;"></div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸ’¬ èŠå¤©</div>
                <div class="chat-container">
                    <div class="chat-messages" id="chatMessages">
                        <div class="chat-message system">æ¬¢è¿æ¥åˆ°è¿œç¨‹è±¡æ£‹ï¼å…ˆé€‰æ‹©é˜µè¥...</div>
                    </div>
                    <div class="chat-input-area">
                        <input type="text" class="chat-input" id="chatInput" placeholder="è¾“å…¥æ¶ˆæ¯..." maxlength="100">
                        <button class="chat-send" onclick="sendChat()">å‘é€</button>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸ›ï¸ æ“ä½œ</div>
                <button class="btn btn-secondary" onclick="copyGameLink()">ğŸ“‹ å¤åˆ¶å¯¹å±€é“¾æ¥</button>
                <button class="btn btn-secondary" id="undoBtn" onclick="requestUndo()" disabled>â†©ï¸ è¯·æ±‚æ‚”æ£‹</button>
                <button class="btn btn-danger" onclick="resign()">ğŸ³ï¸ è®¤è¾“</button>
                <button class="btn btn-primary" onclick="resetGame()">ğŸ”„ é‡æ–°å¼€å§‹</button>
            </div>
            
            <div class="panel-section">
                <div class="section-title">âš™ï¸ è®¾ç½®</div>
                <div class="settings-row">
                    <span>èµ°æ£‹éŸ³æ•ˆ</span>
                    <div class="toggle active" id="soundToggle" onclick="toggleSound()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸ“ èµ°æ£‹è®°å½•</div>
                <div class="moves-list" id="movesList">
                    <div style="color:#999;text-align:center;">æš‚æ— èµ°æ£‹è®°å½•</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>

    <script>
        // ==================== é…ç½®ï¼ˆä½¿ç”¨ CORS ä»£ç†ï¼‰====================
        const GIST_ID = '932c2d47035c60f134c28cce0b08428e';
        const CORS_PROXY = 'https://cors-anywhere.herokuapp.com/';
        const GIST_API = `${CORS_PROXY}https://api.github.com/gists/${GIST_ID}`;
        const GITHUB_TOKEN = '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';
        
        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        let gameState = {
            board: [], turn: 'red', lastMove: null, moveCount: 0,
            timestamp: Date.now(), players: { red: null, black: null },
            status: 'waiting', moves: [], chat: [], undoRequest: null,
            timers: { red: 600, black: 600 }, timerRunning: false
        };
        
        let myColor = null, selectedPiece = null;
        let myPlayerId = localStorage.getItem('chess_player_id') || generateId();
        let syncInterval = null, isSyncing = false, soundEnabled = true;
        let timerInterval = null, lastTimerUpdate = Date.now(), isFirstLoad = true;
        
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const pieceNames = {
            'R': 'è½¦', 'N': 'é©¬', 'B': 'è±¡', 'A': 'å£«', 'K': 'å°†', 'C': 'ç‚®', 'P': 'å…µ',
            'r': 'è½¦', 'n': 'é©¬', 'b': 'ç›¸', 'a': 'ä»•', 'k': 'å¸…', 'c': 'ç‚®', 'p': 'å’'
        };
        
        function playSound(type) {
            if (!soundEnabled) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'move': oscillator.frequency.value = 400; gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.1); break;
                case 'capture': oscillator.frequency.value = 200; gainNode.gain.setValueAtTime(0.5, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.2); break;
                case 'check': oscillator.frequency.value = 800; gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.3); break;
                case 'win': oscillator.frequency.value = 600; gainNode.gain.setValueAtTime(0.4, audioContext.currentTime); oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.5); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.5); break;
                case 'select': oscillator.frequency.value = 600; gainNode.gain.setValueAtTime(0.2, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.05); break;
            }
        }
        
        function toggleSound() { soundEnabled = !soundEnabled; document.getElementById('soundToggle').classList.toggle('active'); showToast(soundEnabled ? 'éŸ³æ•ˆå·²å¼€å¯' : 'éŸ³æ•ˆå·²å…³é—­'); }
        
        function init() {
            localStorage.setItem('chess_player_id', myPlayerId);
            drawBoard(); initBoard(false); loadGame(); startSync(); startTimer();
            setupChatInput(); updateRoleButtons(); checkProxy();
        }
        
        function generateId() { return 'player_' + Math.random().toString(36).substr(2, 9); }
        function setupChatInput() { document.getElementById('chatInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') sendChat(); }); }
        
        async function checkProxy() {
            try {
                const response = await fetch(GIST_API, { method: 'HEAD', headers: { 'Authorization': `token ${GITHUB_TOKEN}` } });
                if (response.ok) { document.getElementById('proxySection').style.display = 'none'; showToast('ä»£ç†è¿æ¥æˆåŠŸï¼'); }
            } catch (err) { showToast('è¯·æ¿€æ´»ä»£ç†ï¼ˆç‚¹å‡»ä¸Šæ–¹é»„è‰²æç¤ºï¼‰'); }
        }
        
        function selectRole(color) {
            if (myColor) { showToast('ä½ å·²ç»é€‰æ‹©äº†é˜µè¥ï¼'); return; }
            if (gameState.players[color] && gameState.players[color] !== myPlayerId) { showToast('è¯¥é˜µè¥å·²è¢«é€‰æ‹©ï¼Œè¯·é€‰æ‹©å¦ä¸€ä¸ªï¼'); return; }
            
            myColor = color; gameState.players[color] = myPlayerId;
            document.getElementById('playerRole').textContent = color === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹';
            document.getElementById('playerRole').className = `player-badge ${color}`;
            document.getElementById('roleSelection').style.display = 'none';
            
            gameState.chat.push({ sender: 'system', text: `${color === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹'}å·²åŠ å…¥æ¸¸æˆ`, time: Date.now() });
            if (gameState.players.red && gameState.players.black) {
                gameState.status = 'playing'; gameState.timerRunning = true;
                gameState.chat.push({ sender: 'system', text: 'æ¸¸æˆå¼€å§‹ï¼çº¢æ–¹å…ˆè¡Œ', time: Date.now() });
            }
            playSound('select'); renderChat(); updateRoleButtons(); saveGame();
            showToast(`ä½ æ˜¯${color === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹'}ï¼`);
        }
        
        function updateRoleButtons() {
            const btnRed = document.getElementById('btnRed'), btnBlack = document.getElementById('btnBlack');
            btnRed.className = 'role-btn red'; btnBlack.className = 'role-btn black';
            if (gameState.players.red) { btnRed.classList.add('disabled'); if (gameState.players.red === myPlayerId) btnRed.classList.add('selected'); }
            if (gameState.players.black) { btnBlack.classList.add('disabled'); if (gameState.players.black === myPlayerId) btnBlack.classList.add('selected'); }
            if (myColor) document.getElementById('roleSelection').style.display = 'none';
        }
        
        function startTimer() {
            timerInterval = setInterval(() => {
                if (gameState.status !== 'playing' || !gameState.timerRunning) return;
                const now = Date.now(), delta = Math.floor((now - lastTimerUpdate) / 1000);
                if (delta >= 1) {
                    if (gameState.turn === 'red') gameState.timers.red = Math.max(0, gameState.timers.red - delta);
                    else gameState.timers.black = Math.max(0, gameState.timers.black - delta);
                    if (gameState.timers.red === 0 || gameState.timers.black === 0) {
                        const winner = gameState.timers.red === 0 ? 'é»‘æ–¹' : 'çº¢æ–¹';
                        showToast(`â° æ—¶é—´åˆ°ï¼${winner}è·èƒœï¼`); gameState.status = 'finished'; playSound('win');
                    }
                    updateTimerDisplay(); lastTimerUpdate = now;
                }
            }, 1000);
        }
        
        function updateTimerDisplay() {
            document.getElementById('timeRed').textContent = formatTime(gameState.timers.red);
            document.getElementById('timeBlack').textContent = formatTime(gameState.timers.black);
            document.getElementById('timerRed').classList.toggle('active', gameState.turn === 'red' && gameState.status === 'playing');
            document.getElementById('timerBlack').classList.toggle('active', gameState.turn === 'black' && gameState.status === 'playing');
        }
        
        function formatTime(seconds) { const mins = Math.floor(seconds / 60), secs = seconds % 60; return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`; }
        
        function sendChat() {
            const input = document.getElementById('chatInput'), message = input.value.trim();
            if (!message) return; if (!myColor) { showToast('è¯·å…ˆé€‰æ‹©é˜µè¥'); return; }
            gameState.chat.push({ sender: myColor, playerId: myPlayerId, text: message, time: Date.now() });
            input.value = ''; renderChat(); saveGame();
        }
        
        function renderChat() {
            const container = document.getElementById('chatMessages'); container.innerHTML = '';
            gameState.chat.slice(-50).forEach(msg => {
                const div = document.createElement('div'); div.className = 'chat-message';
                if (msg.sender === 'system') { div.className += ' system'; div.textContent = msg.text; }
                else {
                    const isOwn = msg.playerId === myPlayerId; div.className += isOwn ? ' own' : ' other';
                    const sender = document.createElement('div'); sender.className = 'chat-sender'; sender.textContent = msg.sender === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹'; div.appendChild(sender);
                    const text = document.createElement('div'); text.textContent = msg.text; div.appendChild(text);
                }
                container.appendChild(div);
            });
            container.scrollTop = container.scrollHeight;
        }
        
        function requestUndo() {
            if (!myColor || gameState.moves.length === 0) { showToast('ç°åœ¨ä¸èƒ½æ‚”æ£‹'); return; }
            if (gameState.undoRequest) { showToast('å·²ç»æœ‰ä¸€ä¸ªæ‚”æ£‹è¯·æ±‚äº†'); return; }
            gameState.undoRequest = { requester: myColor, moveCount: gameState.moveCount, timestamp: Date.now() };
            saveGame(); showToast('å·²å‘é€æ‚”æ£‹è¯·æ±‚ï¼Œç­‰å¾…å¯¹æ–¹åŒæ„'); checkUndoRequest();
        }
        
        function checkUndoRequest() {
            const area = document.getElementById('undoRequestArea');
            if (!gameState.undoRequest) { area.style.display = 'none'; area.innerHTML = ''; return; }
            const isRequester = gameState.undoRequest.requester === myColor;
            if (isRequester) { area.style.display = 'block'; area.innerHTML = '<div style="color:#856404;">ç­‰å¾…å¯¹æ–¹åŒæ„æ‚”æ£‹...</div>'; }
            else { area.style.display = 'block'; area.innerHTML = `<div class="undo-request"><div>å¯¹æ–¹è¯·æ±‚æ‚”æ£‹ï¼ˆå›åˆ°ç¬¬${gameState.undoRequest.moveCount}æ­¥ï¼‰</div><div class="undo-buttons"><button class="btn btn-primary" onclick="acceptUndo()">åŒæ„</button><button class="btn btn-secondary" onclick="rejectUndo()">æ‹’ç»</button></div></div>`; }
        }
        
        function acceptUndo() { const targetMove = gameState.undoRequest.moveCount; initBoard(false); gameState.undoRequest = null; gameState.chat.push({ sender: 'system', text: `æ‚”æ£‹æˆåŠŸï¼Œå›é€€åˆ°ç¬¬${targetMove}æ­¥`, time: Date.now() }); saveGame(); showToast('å·²åŒæ„æ‚”æ£‹'); renderChat(); }
        function rejectUndo() { gameState.undoRequest = null; gameState.chat.push({ sender: 'system', text: 'æ‚”æ£‹è¯·æ±‚è¢«æ‹’ç»', time: Date.now() }); saveGame(); showToast('å·²æ‹’ç»æ‚”æ£‹è¯·æ±‚'); renderChat(); }
        
        function drawBoard() {
            const hLines = document.getElementById('hLines'), vLines = document.getElementById('vLines');
            for (let i = 0; i < 10; i++) { const line = document.createElement('div'); line.className = 'horizontal-line'; line.style.top = `${i * 50 + 25}px`; hLines.appendChild(line); }
            for (let i = 0; i < 9; i++) {
                if (i === 0 || i === 8) { const line = document.createElement('div'); line.className = 'vertical-line'; line.style.left = `${i * 50 + 25}px`; line.style.top = '25px'; line.style.height = '450px'; vLines.appendChild(line); }
                else {
                    const line1 = document.createElement('div'); line1.className = 'vertical-line'; line1.style.left = `${i * 50 + 25}px`; line1.style.top = '25px'; line1.style.height = '200px'; vLines.appendChild(line1);
                    const line2 = document.createElement('div'); line2.className = 'vertical-line'; line2.style.left = `${i * 50 + 25}px`; line2.style.top = '275px'; line2.style.height = '200px'; vLines.appendChild(line2);
                }
            }
        }
        
        function renderPieces() {
            const container = document.getElementById('piecesContainer'); container.innerHTML = '';
            if (!gameState.board || gameState.board.length === 0) return;
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece !== '.') {
                        const el = document.createElement('div'); el.className = `piece ${piece === piece.toUpperCase() ? 'black' : 'red'}`; el.textContent = pieceNames[piece];
                        el.style.left = `${col * 50 + 3}px`; el.style.top = `${row * 50 + 3}px`;
                        if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) el.classList.add('selected');
                        if (gameState.lastMove) { const from = gameState.lastMove.from, to = gameState.lastMove.to; if ((row === from.row && col === from.col) || (row === to.row && col === to.col)) el.classList.add('last-move'); }
                        if (piece.toUpperCase() === 'K' && isInCheck(piece === piece.toLowerCase())) el.classList.add('check');
                        el.onclick = () => onPieceClick(row, col); container.appendChild(el);
                    }
                }
            }
            if (selectedPiece) showMoveHints(selectedPiece.row, selectedPiece.col);
        }
        
        function showMoveHints(row, col) {
            const container = document.getElementById('piecesContainer');
            container.querySelectorAll('.move-hint').forEach(h => h.remove());
            const piece = gameState.board[row][col]; if (!piece || piece === '.') return;
            const isRed = piece === piece.toLowerCase();
            if ((isRed && myColor !== 'red') || (!isRed && myColor !== 'black')) return;
            if ((isRed && gameState.turn !== 'red') || (!isRed && gameState.turn !== 'black')) return;
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const hint = document.createElement('div'); hint.className = 'move-hint'; hint.style.left = `${c * 50 + 25}px`; hint.style.top = `${r * 50 + 25}px`;
                        hint.onclick = (e) => { e.stopPropagation(); onHintClick(r, c); }; container.appendChild(hint);
                    }
                }
            }
        }
        
        function onPieceClick(row, col) {
            if (!myColor) { showToast('è¯·å…ˆé€‰æ‹©é˜µè¥ï¼'); return; }
            if (gameState.turn !== myColor) { showToast('è¿˜æ²¡è½®åˆ°ä½ ï¼'); return; }
            if (gameState.status === 'finished') { showToast('æ¸¸æˆå·²ç»“æŸï¼'); return; }
            const piece = gameState.board[row][col]; if (!piece || piece === '.') return;
            const isRed = piece === piece.toLowerCase();
            if ((isRed && myColor !== 'red') || (!isRed && myColor !== 'black')) { showToast('è¿™æ˜¯å¯¹æ–¹çš„æ£‹å­ï¼'); return; }
            playSound('select');
            if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) selectedPiece = null;
            else selectedPiece = { row, col, piece };
            renderPieces();
        }
        
        function onHintClick(row, col) { if (!selectedPiece) return; makeMove(selectedPiece.row, selectedPiece.col, row, col); selectedPiece = null; }
        
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (toRow < 0 || toRow > 9 || toCol < 0 || toCol > 8) return false;
            if (fromRow === toRow && fromCol === toCol) return false;
            const piece = gameState.board[fromRow][fromCol], target = gameState.board[toRow][toCol];
            if (target !== '.' && target !== '') { const isRedPiece = piece === piece.toLowerCase(), isRedTarget = target === target.toLowerCase(); if (isRedPiece === isRedTarget) return false; }
            const type = piece.toUpperCase(), isRed = piece === piece.toLowerCase();
            switch(type) {
                case 'R': return validateRook(fromRow, fromCol, toRow, toCol);
                case 'N': return validateKnight(fromRow, fromCol, toRow, toCol);
                case 'B': return validateBishop(fromRow, fromCol, toRow, toCol, isRed);
                case 'A': return validateAdvisor(fromRow, fromCol, toRow, toCol, isRed);
                case 'K': return validateKing(fromRow, fromCol, toRow, toCol, isRed);
                case 'C': return validateCannon(fromRow, fromCol, toRow, toCol);
                case 'P': return validatePawn(fromRow, fromCol, toRow, toCol, isRed);
                default: return false;
            }
        }
        
        function countPiecesBetween(r1, c1, r2, c2) {
            let count = 0;
            if (r1 === r2) { const min = Math.min(c1, c2), max = Math.max(c1, c2); for (let c = min + 1; c < max; c++) if (gameState.board[r1][c] !== '.' && gameState.board[r1][c] !== '') count++; }
            else if (c1 === c2) { const min = Math.min(r1, r2), max = Math.max(r1, r2); for (let r = min + 1; r < max; r++) if (gameState.board[r][c1] !== '.' && gameState.board[r][c1] !== '') count++; }
            return count;
        }
        
        function validateRook(r1, c1, r2, c2) { if (r1 !== r2 && c1 !== c2) return false; return countPiecesBetween(r1, c1, r2, c2) === 0; }
        function validateKnight(r1, c1, r2, c2) {
            const dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1); if (!((dr === 2 && dc === 1) || (dr === 1 && dc === 2))) return false;
            if (dr === 2) { const blockR = r1 + (r2 > r1 ? 1 : -1); if (gameState.board[blockR][c1] !== '.' && gameState.board[blockR][c1] !== '') return false; }
            else { const blockC = c1 + (c2 > c1 ? 1 : -1); if (gameState.board[r1][blockC] !== '.' && gameState.board[r1][blockC] !== '') return false; }
            return true;
        }
        function validateBishop(r1, c1, r2, c2, isRed) {
            const dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1); if (dr !== 2 || dc !== 2) return false;
            if (isRed && r2 < 5) return false; if (!isRed && r2 > 4) return false;
            const eyeR = (r1 + r2) / 2, eyeC = (c1 + c2) / 2; if (gameState.board[eyeR][eyeC] !== '.' && gameState.board[eyeR][eyeC] !== '') return false;
            return true;
        }
        function validateAdvisor(r1, c1, r2, c2, isRed) {
            const dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1); if (dr !== 1 || dc !== 1) return false;
            if (c2 < 3 || c2 > 5) return false; if (isRed && r2 < 7) return false; if (!isRed && r2 > 2) return false;
            return true;
        }
        function validateKing(r1, c1, r2, c2, isRed) {
            const dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1);
            if (c1 === c2) { let hasPiece = false; const min = Math.min(r1, r2), max = Math.max(r1, r2); for (let r = min + 1; r < max; r++) if (gameState.board[r][c1] !== '.' && gameState.board[r][c1] !== '') { hasPiece = true; break; } if (!hasPiece) { const target = gameState.board[r2][c2]; if (target && (target.toUpperCase() === 'K')) return true; } }
            if (dr + dc !== 1) return false; if (c2 < 3 || c2 > 5) return false; if (isRed && r2 < 7) return false; if (!isRed && r2 > 2) return false;
            return true;
        }
        function validateCannon(r1, c1, r2, c2) {
            if (r1 !== r2 && c1 !== c2) return false;
            const count = countPiecesBetween(r1, c1, r2, c2), target = gameState.board[r2][c2];
            if (target === '.' || target === '') return count === 0;
            else return count === 1;
        }
        function validatePawn(r1, c1, r2, c2, isRed) {
            const dr = r2 - r1, dc = Math.abs(c2 - c1);
            if (isRed) { if (dr > 0) return false; if (r1 >= 5 && dc !== 0) return false; if (dr === -1 && dc === 0) return true; if (r1 < 5 && dr === 0 && dc === 1) return true; }
            else { if (dr < 0) return false; if (r1 <= 4 && dc !== 0) return false; if (dr === 1 && dc === 0) return true; if (r1 > 4 && dr === 0 && dc === 1) return true; }
            return false;
        }
        
        function isInCheck(isRed) {
            let kingRow, kingCol; const kingChar = isRed ? 'k' : 'K';
            for (let r = 0; r < 10; r++) for (let c = 0; c < 9; c++) if (gameState.board[r][c] === kingChar) { kingRow = r; kingCol = c; break; }
            if (kingRow === undefined) return false;
            for (let r = 0; r < 10; r++) for (let c = 0; c < 9; c++) { const piece = gameState.board[r][c]; if (piece !== '.' && piece !== '') { const pieceIsRed = piece === piece.toLowerCase(); if (pieceIsRed !== isRed) if (isValidMove(r, c, kingRow, kingCol)) return true; } }
            return false;
        }
        
        async function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol], target = gameState.board[toRow][toCol], isCapture = target !== '.' && target !== '';
            gameState.board[toRow][toCol] = piece; gameState.board[fromRow][fromCol] = '.';
            gameState.moves.push(`${pieceNames[piece]} ${String.fromCharCode(97 + fromCol)}${9-fromRow}â†’${String.fromCharCode(97 + toCol)}${9-toRow}`);
            gameState.lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };
            gameState.turn = gameState.turn === 'red' ? 'black' : 'red'; gameState.moveCount++; gameState.timestamp = Date.now(); gameState.timerRunning = true; lastTimerUpdate = Date.now();
            isCapture ? playSound('capture') : playSound('move');
            const opponentIsRed = gameState.turn === 'red'; if (isInCheck(opponentIsRed)) { playSound('check'); showToast('å°†å†›ï¼'); }
            if (target && target.toUpperCase() === 'K') { const winner = gameState.turn === 'red' ? 'é»‘æ–¹' : 'çº¢æ–¹'; showToast(`ğŸ‰ ${winner}è·èƒœï¼`); gameState.status = 'finished'; gameState.timerRunning = false; playSound('win'); gameState.chat.push({ sender: 'system', text: `ğŸ‰ ${winner}è·èƒœï¼`, time: Date.now() }); renderChat(); }
            renderPieces(); updateUI(); await saveGame();
        }
        
        function updateUI() {
            document.getElementById('currentTurn').textContent = gameState.turn === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹';
            document.getElementById('currentTurn').style.color = gameState.turn === 'red' ? '#c62828' : '#333';
            updateTimerDisplay();
            const movesList = document.getElementById('movesList');
            if (gameState.moves.length === 0) movesList.innerHTML = '<div style="color:#999;text-align:center;">æš‚æ— èµ°æ£‹è®°å½•</div>';
            else { movesList.innerHTML = gameState.moves.map((m, i) => { const isRed = i % 2 === 0; return `<div class="move-item"><span class="move-number">${Math.floor(i/2)+1}.</span><span class="${isRed ? 'move-red' : 'move-black'}">${m}</span></div>`; }).join(''); movesList.scrollTop = movesList.scrollHeight; }
            document.getElementById('undoBtn').disabled = !myColor || gameState.moves.length === 0 || gameState.status === 'finished';
        }
        
        async function loadGame() {
            try {
                const response = await fetch(GIST_API, { headers: { 'Authorization': `token ${GITHUB_TOKEN}` } });
                if (!response.ok) { if (response.status === 403) { showToast('è¯·æ¿€æ´»ä»£ç†ï¼ˆç‚¹å‡»ä¸Šæ–¹é»„è‰²æç¤ºï¼‰'); document.getElementById('proxySection').style.display = 'block'; } throw new Error('Failed to load'); }
                const gist = await response.json(), content = gist.files['chess-game.json'].content, data = JSON.parse(content);
                const needSync = data.timestamp > gameState.timestamp || data.status !== gameState.status || (data.chat && data.chat.length > (gameState.chat || []).length);
                if (needSync || isFirstLoad) {
                    isFirstLoad = false;
                    const localColor = myColor, localPlayerId = myPlayerId, localSelected = selectedPiece, chatInputVal = document.getElementById('chatInput').value;
                    gameState = data; myPlayerId = localPlayerId; myColor = localColor; selectedPiece = localSelected;
                    if (myColor && gameState.players[myColor] !== myPlayerId) gameState.players[myColor] = myPlayerId;
                    if (gameState.status === 'finished') { const lastSystemMsg = gameState.chat.filter(m => m.sender === 'system').pop(); if (lastSystemMsg && lastSystemMsg.text.includes('è·èƒœ')) { showToast(lastSystemMsg.text); playSound('win'); } }
                    renderPieces(); updateUI(); renderChat(); checkUndoRequest(); updateRoleButtons(); document.getElementById('chatInput').value = chatInputVal; document.getElementById('proxySection').style.display = 'none';
                }
                updateConnectionStatus(true);
            } catch (err) { console.error('Load error:', err); updateConnectionStatus(false); if (gameState.board.length === 0) initBoard(false); }
        }
        
        async function saveGame() {
            if (isSyncing) return; isSyncing = true; updateConnectionStatus(true, true);
            try {
                const response = await fetch(GIST_API, { method: 'PATCH', headers: { 'Content-Type': 'application/json', 'Accept': 'application/vnd.github.v3+json', 'Authorization': `token ${GITHUB_TOKEN}` }, body: JSON.stringify({ files: { 'chess-game.json': { content: JSON.stringify(gameState, null, 2) } } }) });
                if (!response.ok) { if (response.status === 403) { showToast('è¯·æ¿€æ´»ä»£ç†ï¼ˆç‚¹å‡»ä¸Šæ–¹é»„è‰²æç¤ºï¼‰'); document.getElementById('proxySection').style.display = 'block'; } throw new Error('Failed to save'); }
                updateConnectionStatus(true);
            } catch (err) { console.error('Save error:', err); showToast('ä¿å­˜å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–æ¿€æ´»ä»£ç†'); updateConnectionStatus(false); }
            finally { isSyncing = false; }
        }
        
        function startSync() { syncInterval = setInterval(loadGame, 2000); }
        function updateConnectionStatus(connected, syncing = false) {
            const dot = document.getElementById('statusDot'), text = document.getElementById('statusText');
            if (syncing) { dot.className = 'status-dot syncing'; text.textContent = 'åŒæ­¥ä¸­...'; }
            else if (connected) { dot.className = 'status-dot connected'; text.textContent = 'å·²è¿æ¥'; }
            else { dot.className = 'status-dot'; text.textContent = 'æœªè¿æ¥'; }
        }
        
        function initBoard(save = true) {
            gameState.board = [['R','N','B','A','K','A','B','N','R'],['.','.','.','.','.','.','.','.','.'],['.','C','.','.','.','.','.','C','.'],['P','.','P','.','P','.','P','.','P'],['.','.','.','.','.','.','.','.','.'],['.','.','.','.','.','.','.','.','.'],['p','.','p','.','p','.','p','.','p'],['.','c','.','.','.','.','.','c','.'],['.','.','.','.','.','.','.','.','.'],['r','n','b','a','k','a','b','n','r']];
            gameState.turn = 'red'; gameState.lastMove = null; gameState.moveCount = 0; gameState.moves = []; gameState.status = 'waiting'; gameState.timers = { red: 600, black: 600 }; gameState.timerRunning = false; gameState.undoRequest = null; gameState.timestamp = Date.now();
            if (!gameState.chat) gameState.chat = [];
            renderPieces(); updateUI(); renderChat(); checkUndoRequest();
            if (save) saveGame();
        }
        
        function copyGameLink() { navigator.clipboard.writeText(window.location.href).then(() => showToast('é“¾æ¥å·²å¤åˆ¶ï¼Œåˆ†äº«ç»™å§¥çˆ·å§ï¼')); }
        
        function resign() {
            if (!myColor) { showToast('è¯·å…ˆé€‰æ‹©é˜µè¥'); return; }
            if (!confirm('ç¡®å®šè¦è®¤è¾“å—ï¼Ÿ')) return;
            const winner = myColor === 'red' ? 'é»‘æ–¹' : 'çº¢æ–¹';
            gameState.status = 'finished'; gameState.timerRunning = false;
            const msg = `${myColor === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹'}è®¤è¾“ï¼Œ${winner}è·èƒœï¼`;
            gameState.chat.push({ sender: 'system', text: msg, time: Date.now() });
            showToast(`ä½ è®¤è¾“äº†ï¼Œ${winner}è·èƒœï¼`); playSound('win');
            saveGame(); renderChat(); updateUI();
        }
        
        async function resetGame() {
            if (!confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹å—ï¼Ÿ')) return;
            const savedRed = gameState.players.red, savedBlack = gameState.players.black;
            initBoard(false);
            gameState.players.red = savedRed; gameState.players.black = savedBlack;
            if (savedRed && savedBlack) { gameState.status = 'playing'; gameState.timerRunning = true; }
            gameState.chat.push({ sender: 'system', text: 'æ¸¸æˆå·²é‡ç½®ï¼', time: Date.now() });
            await saveGame(); showToast('æ¸¸æˆå·²é‡ç½®ï¼'); renderChat();
        }
        
        function showToast(msg) { const toast = document.getElementById('toast'); toast.textContent = msg; toast.classList.add('show'); setTimeout(() => toast.classList.remove('show'), 3000); }
        
        window.onload = init;
    </script>
</body>
</html>
