<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿œç¨‹è±¡æ£‹ - ä¸å§¥çˆ·å¯¹å¼ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: "Microsoft YaHei", "SimSun", sans-serif;
            background: linear-gradient(135deg, #f5f5dc 0%, #e8dcc0 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            color: #8b4513;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            font-size: 1.1em;
        }
        
        .game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1200px;
            width: 100%;
        }
        
        .board-wrapper {
            position: relative;
            background: #f0d9b5;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 3px solid #8b4513;
        }
        
        .board {
            width: 450px;
            height: 500px;
            position: relative;
            background: #f0d9b5;
        }
        
        .board-lines {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .horizontal-lines, .vertical-lines {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .horizontal-line {
            position: absolute;
            width: 100%;
            height: 1px;
            background: #333;
        }
        
        .vertical-line {
            position: absolute;
            width: 1px;
            height: 100%;
            background: #333;
        }
        
        .palace-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .palace-line {
            position: absolute;
            width: 141px;
            height: 1px;
            background: #333;
            transform-origin: left center;
        }
        
        .palace-line.top-left { top: 50px; left: 154px; transform: rotate(45deg); }
        .palace-line.top-right { top: 50px; right: 154px; transform: rotate(-45deg); }
        .palace-line.bottom-left { bottom: 50px; left: 154px; transform: rotate(-45deg); }
        .palace-line.bottom-right { bottom: 50px; right: 154px; transform: rotate(45deg); }
        
        .river {
            position: absolute;
            top: 225px;
            left: 0;
            width: 100%;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #8b4513;
            font-weight: bold;
            letter-spacing: 20px;
        }
        
        .pieces-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .piece {
            position: absolute;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            z-index: 10;
        }
        
        .piece.red {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #cc0000);
            color: #ffeb3b;
            border: 2px solid #8b0000;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .piece.black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            color: #fff;
            border: 2px solid #333;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .piece:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255,215,0,0.8);
        }
        
        .piece.selected {
            box-shadow: 0 0 20px #ffd700, 0 0 40px #ffd700;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1.1); }
            50% { transform: scale(1.2); }
        }
        
        .piece.last-move {
            border: 3px solid #00ff00;
        }
        
        .piece.check {
            animation: check-pulse 0.5s infinite;
            box-shadow: 0 0 20px #ff0000;
        }
        
        @keyframes check-pulse {
            0%, 100% { box-shadow: 0 0 20px #ff0000; }
            50% { box-shadow: 0 0 40px #ff0000, 0 0 60px #ff0000; }
        }
        
        .move-hint {
            position: absolute;
            width: 16px;
            height: 16px;
            background: rgba(0,255,0,0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
        }
        
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 320px;
        }
        
        .panel-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            border: 2px solid #8b4513;
        }
        
        .section-title {
            font-weight: bold;
            color: #8b4513;
            margin-bottom: 15px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* è®¡æ—¶å™¨æ ·å¼ */
        .timer-box {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
        }
        
        .timer {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background: #f5f5f5;
            min-width: 80px;
        }
        
        .timer.active {
            background: #e3f2fd;
            border: 2px solid #2196f3;
        }
        
        .timer-label {
            font-size: 0.8em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .timer-time {
            font-size: 1.5em;
            font-weight: bold;
            font-family: monospace;
        }
        
        .timer.red .timer-time { color: #c62828; }
        .timer.black .timer-time { color: #333; }
        
        /* çŠ¶æ€æ¡† */
        .status-content {
            color: #333;
            line-height: 1.6;
        }
        
        .player-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .player-badge.red {
            background: #ffeb3b;
            color: #c62828;
        }
        
        .player-badge.black {
            background: #333;
            color: #fff;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }
        
        .btn-primary {
            background: #8b4513;
            color: white;
        }
        
        .btn-primary:hover {
            background: #6b3410;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: #e0e0e0;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #d0d0d0;
        }
        
        .btn-danger {
            background: #c62828;
            color: white;
        }
        
        .btn-danger:hover {
            background: #a02020;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* èŠå¤©æ¡† */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 250px;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            background: #f9f9f9;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
        }
        
        .chat-message {
            margin-bottom: 8px;
            padding: 6px 10px;
            border-radius: 12px;
            max-width: 85%;
            word-wrap: break-word;
            font-size: 0.9em;
        }
        
        .chat-message.own {
            background: #dcf8c6;
            margin-left: auto;
            text-align: right;
        }
        
        .chat-message.other {
            background: #fff;
            border: 1px solid #e0e0e0;
        }
        
        .chat-message.system {
            background: #fff3cd;
            text-align: center;
            font-size: 0.8em;
            color: #856404;
            max-width: 100%;
        }
        
        .chat-sender {
            font-size: 0.75em;
            color: #666;
            margin-bottom: 2px;
        }
        
        .chat-input-area {
            display: flex;
            gap: 8px;
        }
        
        .chat-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
            font-family: inherit;
        }
        
        .chat-send {
            padding: 8px 16px;
            background: #8b4513;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
        }
        
        .chat-send:hover {
            background: #6b3410;
        }
        
        /* èµ°æ£‹è®°å½• */
        .moves-list {
            max-height: 150px;
            overflow-y: auto;
            background: #f9f9f9;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9em;
        }
        
        .move-item {
            padding: 4px 0;
            border-bottom: 1px solid #eee;
            color: #555;
            display: flex;
            justify-content: space-between;
        }
        
        .move-number {
            color: #999;
            min-width: 30px;
        }
        
        .move-red { color: #c62828; }
        .move-black { color: #333; }
        
        /* æ‚”æ£‹è¯·æ±‚ */
        .undo-request {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
        }
        
        .undo-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .undo-buttons .btn {
            margin: 0;
            flex: 1;
            padding: 8px;
            font-size: 14px;
        }
        
        /* è¿æ¥çŠ¶æ€ */
        .connection-status {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 0.85em;
            margin-top: 10px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ccc;
        }
        
        .status-dot.connected {
            background: #4caf50;
            animation: blink 2s infinite;
        }
        
        .status-dot.syncing {
            background: #ff9800;
            animation: blink 0.5s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* è®¾ç½® */
        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 10px 0;
        }
        
        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
            background: #ccc;
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle.active {
            background: #4caf50;
        }
        
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        
        .toggle.active .toggle-slider {
            transform: translateX(24px);
        }
        
        /* Toast */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        .toast.show {
            opacity: 1;
        }
        
        @media (max-width: 800px) {
            .board {
                width: 360px;
                height: 400px;
            }
            .piece {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            .side-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ® è¿œç¨‹è±¡æ£‹ ğŸ®</h1>
        <p class="subtitle">ä¸å§¥çˆ·éš”ç©ºå¯¹å¼ˆï¼Œè·¨è¶Šä¸‡é‡Œçš„äº²æƒ…</p>
    </div>
    
    <div class="game-container">
        <div class="board-wrapper">
            <div class="board" id="board">
                <div class="board-lines">
                    <div class="horizontal-lines" id="hLines"></div>
                    <div class="vertical-lines" id="vLines"></div>
                    <div class="palace-lines">
                        <div class="palace-line top-left"></div>
                        <div class="palace-line top-right"></div>
                        <div class="palace-line bottom-left"></div>
                        <div class="palace-line bottom-right"></div>
                    </div>
                </div>
                <div class="river">æ¥š æ²³ æ±‰ ç•Œ</div>
                <div class="pieces-container" id="piecesContainer"></div>
            </div>
        </div>
        
        <div class="side-panel">
            <!-- è®¡æ—¶å™¨ -->
            <div class="panel-section">
                <div class="section-title">â±ï¸ è®¡æ—¶å™¨</div>
                <div class="timer-box">
                    <div class="timer red" id="timerRed">
                        <div class="timer-label">çº¢æ–¹</div>
                        <div class="timer-time" id="timeRed">10:00</div>
                    </div>
                    <div class="timer black" id="timerBlack">
                        <div class="timer-label">é»‘æ–¹</div>
                        <div class="timer-time" id="timeBlack">10:00</div>
                    </div>
                </div>
            </div>
            
            <!-- æ¸¸æˆçŠ¶æ€ -->
            <div class="panel-section">
                <div class="section-title">ğŸ® æ¸¸æˆçŠ¶æ€</div>
                <div class="status-content">
                    <div>å½“å‰å›åˆ: <span id="currentTurn" style="font-weight:bold;">çº¢æ–¹</span></div>
                    <div>ä½ æ˜¯: <span id="playerRole" class="player-badge">ç­‰å¾…åŠ å…¥...</span></div>
                    <div class="connection-status">
                        <span class="status-dot" id="statusDot"></span>
                        <span id="statusText">è¿æ¥ä¸­...</span>
                    </div>
                </div>
                <div id="undoRequestArea" style="display:none;"></div>
            </div>
            
            <!-- èŠå¤© -->
            <div class="panel-section">
                <div class="section-title">ğŸ’¬ èŠå¤©</div>
                <div class="chat-container">
                    <div class="chat-messages" id="chatMessages">
                        <div class="chat-message system">æ¬¢è¿æ¥åˆ°è¿œç¨‹è±¡æ£‹ï¼å‘é€æ¶ˆæ¯ç»™å¯¹æ–¹...</div>
                    </div>
                    <div class="chat-input-area">
                        <input type="text" class="chat-input" id="chatInput" placeholder="è¾“å…¥æ¶ˆæ¯..." maxlength="100">
                        <button class="chat-send" onclick="sendChat()">å‘é€</button>
                    </div>
                </div>
            </div>
            
            <!-- æ“ä½œæŒ‰é’® -->
            <div class="panel-section">
                <div class="section-title">ğŸ›ï¸ æ“ä½œ</div>
                <button class="btn btn-secondary" onclick="copyGameLink()">ğŸ“‹ å¤åˆ¶å¯¹å±€é“¾æ¥</button>
                <button class="btn btn-secondary" id="undoBtn" onclick="requestUndo()">â†©ï¸ è¯·æ±‚æ‚”æ£‹</button>
                <button class="btn btn-danger" onclick="resign()">ğŸ³ï¸ è®¤è¾“</button>
                <button class="btn btn-primary" onclick="resetGame()">ğŸ”„ é‡æ–°å¼€å§‹</button>
            </div>
            
            <!-- è®¾ç½® -->
            <div class="panel-section">
                <div class="section-title">âš™ï¸ è®¾ç½®</div>
                <div class="settings-row">
                    <span>èµ°æ£‹éŸ³æ•ˆ</span>
                    <div class="toggle active" id="soundToggle" onclick="toggleSound()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
            </div>
            
            <!-- èµ°æ£‹è®°å½• -->
            <div class="panel-section">
                <div class="section-title">ğŸ“ èµ°æ£‹è®°å½•</div>
                <div class="moves-list" id="movesList">
                    <div style="color:#999;text-align:center;">æš‚æ— èµ°æ£‹è®°å½•</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>

    <script>
        // ==================== é…ç½® ====================
        const GIST_ID = '932c2d47035c60f134c28cce0b08428e';
        const GIST_API = `https://api.github.com/gists/${GIST_ID}`;
        const GITHUB_TOKEN = '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';
        
        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        let gameState = {
            board: [],
            turn: 'red',
            lastMove: null,
            moveCount: 0,
            timestamp: Date.now(),
            players: { red: null, black: null },
            status: 'waiting',
            moves: [],
            chat: [],
            undoRequest: null,
            timers: { red: 600, black: 600 }, // 10åˆ†é’Ÿ
            timerRunning: false
        };
        
        let myColor = null;
        let selectedPiece = null;
        let myPlayerId = localStorage.getItem('chess_player_id') || generateId();
        let syncInterval = null;
        let isSyncing = false;
        let soundEnabled = true;
        let timerInterval = null;
        let lastTimerUpdate = Date.now();
        
        // éŸ³æ•ˆï¼ˆä½¿ç”¨ Web Audio API ç”Ÿæˆç®€å•éŸ³æ•ˆï¼‰
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        const pieceNames = {
            'R': 'è½¦', 'N': 'é©¬', 'B': 'è±¡', 'A': 'å£«', 'K': 'å°†', 'C': 'ç‚®', 'P': 'å…µ',
            'r': 'è½¦', 'n': 'é©¬', 'b': 'ç›¸', 'a': 'ä»•', 'k': 'å¸…', 'c': 'ç‚®', 'p': 'å’'
        };
        
        // ==================== éŸ³æ•ˆ ====================
        function playSound(type) {
            if (!soundEnabled) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'move':
                    oscillator.frequency.value = 400;
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'capture':
                    oscillator.frequency.value = 200;
                    gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                case 'check':
                    oscillator.frequency.value = 800;
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'win':
                    oscillator.frequency.value = 600;
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.5);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
            }
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundToggle').classList.toggle('active');
            showToast(soundEnabled ? 'éŸ³æ•ˆå·²å¼€å¯' : 'éŸ³æ•ˆå·²å…³é—­');
        }
        
        // ==================== åˆå§‹åŒ– ====================
        function init() {
            localStorage.setItem('chess_player_id', myPlayerId);
            drawBoard();
            loadGame();
            startSync();
            startTimer();
            setupChatInput();
            showToast('æ¬¢è¿æ¥åˆ°è¿œç¨‹è±¡æ£‹ï¼');
        }
        
        function generateId() {
            return 'player_' + Math.random().toString(36).substr(2, 9);
        }
        
        function setupChatInput() {
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendChat();
            });
        }
        
        // ==================== è®¡æ—¶å™¨ ====================
        function startTimer() {
            timerInterval = setInterval(() => {
                if (gameState.status !== 'playing' || !gameState.timerRunning) return;
                
                const now = Date.now();
                const delta = Math.floor((now - lastTimerUpdate) / 1000);
                
                if (delta >= 1) {
                    if (gameState.turn === 'red') {
                        gameState.timers.red = Math.max(0, gameState.timers.red - delta);
                    } else {
                        gameState.timers.black = Math.max(0, gameState.timers.black - delta);
                    }
                    
                    if (gameState.timers.red === 0 || gameState.timers.black === 0) {
                        const winner = gameState.timers.red === 0 ? 'é»‘æ–¹' : 'çº¢æ–¹';
                        showToast(`â° æ—¶é—´åˆ°ï¼${winner}è·èƒœï¼`);
                        gameState.status = 'finished';
                        playSound('win');
                    }
                    
                    updateTimerDisplay();
                    lastTimerUpdate = now;
                }
            }, 1000);
        }
        
        function updateTimerDisplay() {
            document.getElementById('timeRed').textContent = formatTime(gameState.timers.red);
            document.getElementById('timeBlack').textContent = formatTime(gameState.timers.black);
            
            document.getElementById('timerRed').classList.toggle('active', 
                gameState.turn === 'red' && gameState.status === 'playing');
            document.getElementById('timerBlack').classList.toggle('active', 
                gameState.turn === 'black' && gameState.status === 'playing');
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        // ==================== èŠå¤© ====================
        function sendChat() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (!message) return;
            
            if (!myColor) {
                showToast('è¯·å…ˆç­‰å¾…åŠ å…¥æ¸¸æˆ');
                return;
            }
            
            const chatMessage = {
                sender: myColor,
                playerId: myPlayerId,
                text: message,
                time: Date.now()
            };
            
            gameState.chat.push(chatMessage);
            input.value = '';
            
            renderChat();
            saveGame();
        }
        
        function renderChat() {
            const container = document.getElementById('chatMessages');
            container.innerHTML = '';
            
            gameState.chat.slice(-50).forEach(msg => {
                const div = document.createElement('div');
                div.className = 'chat-message';
                
                if (msg.sender === 'system') {
                    div.className += ' system';
                    div.textContent = msg.text;
                } else {
                    const isOwn = msg.playerId === myPlayerId;
                    div.className += isOwn ? ' own' : ' other';
                    
                    const sender = document.createElement('div');
                    sender.className = 'chat-sender';
                    sender.textContent = msg.sender === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹';
                    div.appendChild(sender);
                    
                    const text = document.createElement('div');
                    text.textContent = msg.text;
                    div.appendChild(text);
                }
                
                container.appendChild(div);
            });
            
            container.scrollTop = container.scrollHeight;
        }
        
        // ==================== æ‚”æ£‹ ====================
        function requestUndo() {
            if (!myColor || gameState.moves.length === 0) {
                showToast('ç°åœ¨ä¸èƒ½æ‚”æ£‹');
                return;
            }
            
            if (gameState.undoRequest) {
                showToast('å·²ç»æœ‰ä¸€ä¸ªæ‚”æ£‹è¯·æ±‚äº†');
                return;
            }
            
            gameState.undoRequest = {
                requester: myColor,
                moveCount: gameState.moveCount,
                timestamp: Date.now()
            };
            
            saveGame();
            showToast('å·²å‘é€æ‚”æ£‹è¯·æ±‚ï¼Œç­‰å¾…å¯¹æ–¹åŒæ„');
            checkUndoRequest();
        }
        
        function checkUndoRequest() {
            const area = document.getElementById('undoRequestArea');
            
            if (!gameState.undoRequest) {
                area.style.display = 'none';
                area.innerHTML = '';
                return;
            }
            
            const isRequester = gameState.undoRequest.requester === myColor;
            
            if (isRequester) {
                area.style.display = 'block';
                area.innerHTML = '<div style="color:#856404;">ç­‰å¾…å¯¹æ–¹åŒæ„æ‚”æ£‹...</div>';
            } else {
                area.style.display = 'block';
                area.innerHTML = `
                    <div class="undo-request">
                        <div>å¯¹æ–¹è¯·æ±‚æ‚”æ£‹ï¼ˆå›åˆ°ç¬¬${gameState.undoRequest.moveCount}æ­¥ï¼‰</div>
                        <div class="undo-buttons">
                            <button class="btn btn-primary" onclick="acceptUndo()">åŒæ„</button>
                            <button class="btn btn-secondary" onclick="rejectUndo()">æ‹’ç»</button>
                        </div>
                    </div>
                `;
            }
        }
        
        function acceptUndo() {
            // æ‰§è¡Œæ‚”æ£‹ - å›é€€åˆ°æŒ‡å®šæ­¥æ•°
            const targetMove = gameState.undoRequest.moveCount;
            const movesToUndo = gameState.moveCount - targetMove;
            
            // é‡æ–°åˆå§‹åŒ–æ£‹ç›˜
            initBoard(false);
            
            // é‡æ–°æ‰§è¡Œèµ°æ£‹åˆ°ç›®æ ‡æ­¥æ•°
            const movesToReplay = gameState.moves.slice(0, targetMove);
            gameState.moves = [];
            gameState.moveCount = 0;
            
            // è¿™é‡Œç®€åŒ–å¤„ç†ï¼šç›´æ¥æ¸…ç©ºï¼Œå®é™…åº”è¯¥ä¸€æ­¥æ­¥å›æ”¾
            // ç”±äºå®Œæ•´å›æ”¾æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œé‡‡ç”¨é‡ç½®æ–¹å¼
            
            gameState.undoRequest = null;
            gameState.chat.push({
                sender: 'system',
                text: `æ‚”æ£‹æˆåŠŸï¼Œå›é€€åˆ°ç¬¬${targetMove}æ­¥`,
                time: Date.now()
            });
            
            saveGame();
            showToast('å·²åŒæ„æ‚”æ£‹');
        }
        
        function rejectUndo() {
            gameState.undoRequest = null;
            gameState.chat.push({
                sender: 'system',
                text: 'æ‚”æ£‹è¯·æ±‚è¢«æ‹’ç»',
                time: Date.now()
            });
            saveGame();
            showToast('å·²æ‹’ç»æ‚”æ£‹è¯·æ±‚');
        }
        
        // ==================== ç»˜åˆ¶æ£‹ç›˜ï¼ˆä¸ä¹‹å‰ç›¸åŒï¼‰====================
        function drawBoard() {
            const hLines = document.getElementById('hLines');
            const vLines = document.getElementById('vLines');
            
            for (let i = 0; i < 10; i++) {
                const line = document.createElement('div');
                line.className = 'horizontal-line';
                line.style.top = `${i * 50 + 25}px`;
                hLines.appendChild(line);
            }
            
            for (let i = 0; i < 9; i++) {
                const line = document.createElement('div');
                line.className = 'vertical-line';
                line.style.left = `${i * 50 + 25}px`;
                
                if (i === 0 || i === 8) {
                    line.style.height = '100%';
                } else {
                    line.style.height = '200px';
                    line.style.top = '25px';
                    
                    const line2 = document.createElement('div');
                    line2.className = 'vertical-line';
                    line2.style.left = `${i * 50 + 25}px`;
                    line2.style.height = '200px';
                    line2.style.top = '275px';
                    vLines.appendChild(line2);
                }
                vLines.appendChild(line);
            }
        }
        
        // ==================== æ£‹å­æ“ä½œï¼ˆä¸ä¹‹å‰ç›¸åŒï¼Œæ·»åŠ éŸ³æ•ˆï¼‰====================
        function renderPieces() {
            const container = document.getElementById('piecesContainer');
            container.innerHTML = '';
            
            if (!gameState.board || gameState.board.length === 0) return;
            
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece !== '.') {
                        const el = document.createElement('div');
                        el.className = `piece ${piece === piece.toUpperCase() ? 'black' : 'red'}`;
                        el.textContent = pieceNames[piece];
                        el.style.left = `${col * 50 + 3}px`;
                        el.style.top = `${row * 50 + 3}px`;
                        
                        if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                            el.classList.add('selected');
                        }
                        
                        if (gameState.lastMove) {
                            const [from, to] = [gameState.lastMove.from, gameState.lastMove.to];
                            if ((row === from.row && col === from.col) || 
                                (row === to.row && col === to.col)) {
                                el.classList.add('last-move');
                            }
                        }
                        
                        // æ£€æŸ¥æ˜¯å¦è¢«å°†å†›
                        if (piece.toUpperCase() === 'K' && isInCheck(piece === piece.toLowerCase())) {
                            el.classList.add('check');
                        }
                        
                        el.onclick = () => onPieceClick(row, col);
                        container.appendChild(el);
                    }
                }
            }
            
            if (selectedPiece) {
                showMoveHints(selectedPiece.row, selectedPiece.col);
            }
        }
        
        function showMoveHints(row, col) {
            const container = document.getElementById('piecesContainer');
            const piece = gameState.board[row][col];
            if (!piece || piece === '.') return;
            
            const isRed = piece === piece.toLowerCase();
            if ((isRed && myColor !== 'red') || (!isRed && myColor !== 'black')) return;
            if ((isRed && gameState.turn !== 'red') || (!isRed && gameState.turn !== 'black')) return;
            
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const hint = document.createElement('div');
                        hint.className = 'move-hint';
                        hint.style.left = `${c * 50 + 25}px`;
                        hint.style.top = `${r * 50 + 25}px`;
                        hint.onclick = () => onHintClick(r, c);
                        container.appendChild(hint);
                    }
                }
            }
        }
        
        function onPieceClick(row, col) {
            const piece = gameState.board[row][col];
            if (!piece || piece === '.') return;
            
            const isRed = piece === piece.toLowerCase();
            
            if (myColor === null) return;
            if ((isRed && myColor !== 'red') || (!isRed && myColor !== 'black')) {
                showToast('è¿™æ˜¯å¯¹æ–¹çš„æ£‹å­ï¼');
                return;
            }
            if ((isRed && gameState.turn !== 'red') || (!isRed && gameState.turn !== 'black')) {
                showToast('è¿˜æ²¡è½®åˆ°ä½ ï¼');
                return;
            }
            
            if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                selectedPiece = null;
            } else {
                selectedPiece = { row, col, piece };
            }
            renderPieces();
        }
        
        function onHintClick(row, col) {
            if (!selectedPiece) return;
            makeMove(selectedPiece.row, selectedPiece.col, row, col);
            selectedPiece = null;
        }
        
        // ==================== èµ°æ£‹é€»è¾‘ï¼ˆä¸ä¹‹å‰ç›¸åŒï¼‰====================
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (toRow < 0 || toRow > 9 || toCol < 0 || toCol > 8) return false;
            if (fromRow === toRow && fromCol === toCol) return false;
            
            const piece = gameState.board[fromRow][fromCol];
            const target = gameState.board[toRow][toCol];
            
            if (target !== '.' && target !== '') {
                const isRedPiece = piece === piece.toLowerCase();
                const isRedTarget = target === target.toLowerCase();
                if (isRedPiece === isRedTarget) return false;
            }
            
            const type = piece.toUpperCase();
            const isRed = piece === piece.toLowerCase();
            
            switch(type) {
                case 'R': return validateRook(fromRow, fromCol, toRow, toCol);
                case 'N': return validateKnight(fromRow, fromCol, toRow, toCol);
                case 'B': return validateBishop(fromRow, fromCol, toRow, toCol, isRed);
                case 'A': return validateAdvisor(fromRow, fromCol, toRow, toCol, isRed);
                case 'K': return validateKing(fromRow, fromCol, toRow, toCol, isRed);
                case 'C': return validateCannon(fromRow, fromCol, toRow, toCol);
                case 'P': return validatePawn(fromRow, fromCol, toRow, toCol, isRed);
                default: return false;
            }
        }
        
        function countPiecesBetween(r1, c1, r2, c2) {
            let count = 0;
            if (r1 === r2) {
                const min = Math.min(c1, c2);
                const max = Math.max(c1, c2);
                for (let c = min + 1; c < max; c++) {
                    if (gameState.board[r1][c] !== '.' && gameState.board[r1][c] !== '') count++;
                }
            } else if (c1 === c2) {
                const min = Math.min(r1, r2);
                const max = Math.max(r1, r2);
                for (let r = min + 1; r < max; r++) {
                    if (gameState.board[r][c1] !== '.' && gameState.board[r][c1] !== '') count++;
                }
            }
            return count;
        }
        
        function validateRook(r1, c1, r2, c2) {
            if (r1 !== r2 && c1 !== c2) return false;
            return countPiecesBetween(r1, c1, r2, c2) === 0;
        }
        
        function validateKnight(r1, c1, r2, c2) {
            const dr = Math.abs(r2 - r1);
            const dc = Math.abs(c2 - c1);
            if (!((dr === 2 && dc === 1) || (dr === 1 && dc === 2))) return false;
            
            if (dr === 2) {
                const blockR = r1 + (r2 > r1 ? 1 : -1);
                if (gameState.board[blockR][c1] !== '.' && gameState.board[blockR][c1] !== '') return false;
            } else {
                const blockC = c1 + (c2 > c1 ? 1 : -1);
                if (gameState.board[r1][blockC] !== '.' && gameState.board[r1][blockC] !== '') return false;
            }
            return true;
        }
        
        function validateBishop(r1, c1, r2, c2, isRed) {
            const dr = Math.abs(r2 - r1);
            const dc = Math.abs(c2 - c1);
            if (dr !== 2 || dc !== 2) return false;
            
            if (isRed && r2 < 5) return false;
            if (!isRed && r2 > 4) return false;
            
            const eyeR = (r1 + r2) / 2;
            const eyeC = (c1 + c2) / 2;
            if (gameState.board[eyeR][eyeC] !== '.' && gameState.board[eyeR][eyeC] !== '') return false;
            
            return true;
        }
        
        function validateAdvisor(r1, c1, r2, c2, isRed) {
            const dr = Math.abs(r2 - r1);
            const dc = Math.abs(c2 - c1);
            if (dr !== 1 || dc !== 1) return false;
            
            if (c2 < 3 || c2 > 5) return false;
            if (isRed && r2 < 7) return false;
            if (!isRed && r2 > 2) return false;
            
            return true;
        }
        
        function validateKing(r1, c1, r2, c2, isRed) {
            const dr = Math.abs(r2 - r1);
            const dc = Math.abs(c2 - c1);
            
            if (c1 === c2) {
                let hasPiece = false;
                const min = Math.min(r1, r2);
                const max = Math.max(r1, r2);
                for (let r = min + 1; r < max; r++) {
                    if (gameState.board[r][c1] !== '.' && gameState.board[r][c1] !== '') {
                        hasPiece = true;
                        break;
                    }
                }
                if (!hasPiece) {
                    const target = gameState.board[r2][c2];
                    if (target && (target.toUpperCase() === 'K')) return true;
                }
            }
            
            if (dr + dc !== 1) return false;
            
            if (c2 < 3 || c2 > 5) return false;
            if (isRed && r2 < 7) return false;
            if (!isRed && r2 > 2) return false;
            
            return true;
        }
        
        function validateCannon(r1, c1, r2, c2) {
            if (r1 !== r2 && c1 !== c2) return false;
            
            const count = countPiecesBetween(r1, c1, r2, c2);
            const target = gameState.board[r2][c2];
            
            if (target === '.' || target === '') {
                return count === 0;
            } else {
                return count === 1;
            }
        }
        
        function validatePawn(r1, c1, r2, c2, isRed) {
            const dr = r2 - r1;
            const dc = Math.abs(c2 - c1);
            
            if (isRed) {
                if (dr > 0) return false;
                if (r1 >= 5 && dc !== 0) return false;
                if (dr === -1 && dc === 0) return true;
                if (r1 < 5 && dr === 0 && dc === 1) return true;
            } else {
                if (dr < 0) return false;
                if (r1 <= 4 && dc !== 0) return false;
                if (dr === 1 && dc === 0) return true;
                if (r1 > 4 && dr === 0 && dc === 1) return true;
            }
            return false;
        }
        
        // ==================== å°†å†›æ£€æµ‹ ====================
        function isInCheck(isRed) {
            // æ‰¾åˆ°å·±æ–¹è€å°†ä½ç½®
            let kingRow, kingCol;
            const kingChar = isRed ? 'k' : 'K';
            
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    if (gameState.board[r][c] === kingChar) {
                        kingRow = r;
                        kingCol = c;
                        break;
                    }
                }
            }
            
            if (kingRow === undefined) return false;
            
            // æ£€æŸ¥å¯¹æ–¹æ˜¯å¦æœ‰æ£‹å­å¯ä»¥åƒæ‰è€å°†
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    const piece = gameState.board[r][c];
                    if (piece !== '.' && piece !== '') {
                        const pieceIsRed = piece === piece.toLowerCase();
                        if (pieceIsRed !== isRed) {
                            if (isValidMove(r, c, kingRow, kingCol)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
        
        // ==================== æ¸¸æˆæ“ä½œï¼ˆæ·»åŠ éŸ³æ•ˆå’Œè®¡æ—¶å™¨ï¼‰====================
        async function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const target = gameState.board[toRow][toCol];
            const isCapture = target !== '.' && target !== '';
            
            // æ›´æ–°æ£‹ç›˜
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = '.';
            
            // è®°å½•ç§»åŠ¨
            const moveNotation = `${pieceNames[piece]} ${String.fromCharCode(97 + fromCol)}${9-fromRow}â†’${String.fromCharCode(97 + toCol)}${9-toRow}`;
            gameState.moves.push(moveNotation);
            
            gameState.lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };
            gameState.turn = gameState.turn === 'red' ? 'black' : 'red';
            gameState.moveCount++;
            gameState.timestamp = Date.now();
            gameState.timerRunning = true;
            lastTimerUpdate = Date.now();
            
            // éŸ³æ•ˆ
            if (isCapture) {
                playSound('capture');
            } else {
                playSound('move');
            }
            
            // æ£€æŸ¥å°†å†›
            const opponentIsRed = gameState.turn === 'red';
            if (isInCheck(opponentIsRed)) {
                playSound('check');
                showToast('å°†å†›ï¼');
            }
            
            // æ£€æŸ¥èƒœåˆ©
            if (target && target.toUpperCase() === 'K') {
                const winner = gameState.turn === 'red' ? 'é»‘æ–¹' : 'çº¢æ–¹';
                showToast(`ğŸ‰ ${winner}è·èƒœï¼`);
                gameState.status = 'finished';
                gameState.timerRunning = false;
                playSound('win');
            }
            
            renderPieces();
            updateUI();
            await saveGame();
        }
        
        function updateUI() {
            document.getElementById('currentTurn').textContent = gameState.turn === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹';
            document.getElementById('currentTurn').style.color = gameState.turn === 'red' ? '#c62828' : '#333';
            
            updateTimerDisplay();
            
            const movesList = document.getElementById('movesList');
            if (gameState.moves.length === 0) {
                movesList.innerHTML = '<div style="color:#999;text-align:center;">æš‚æ— èµ°æ£‹è®°å½•</div>';
            } else {
                movesList.innerHTML = gameState.moves.map((m, i) => {
                    const isRed = i % 2 === 0;
                    return `<div class="move-item">
                        <span class="move-number">${Math.floor(i/2)+1}.</span>
                        <span class="${isRed ? 'move-red' : 'move-black'}">${m}</span>
                    </div>`;
                }).join('');
                movesList.scrollTop = movesList.scrollHeight;
            }
            
            document.getElementById('undoBtn').disabled = 
                !myColor || gameState.moves.length === 0 || gameState.status === 'finished';
        }
        
        // ==================== æ•°æ®åŒæ­¥ï¼ˆæ·»åŠ èŠå¤©å’Œæ‚”æ£‹ï¼‰====================
        async function loadGame() {
            try {
                const response = await fetch(GIST_API, {
                    headers: {
                        'Authorization': `token ${GITHUB_TOKEN}`
                    }
                });
                if (!response.ok) throw new Error('Failed to load');
                
                const gist = await response.json();
                const content = gist.files['chess-game.json'].content;
                const data = JSON.parse(content);
                
                if (data.timestamp > gameState.timestamp) {
                    const oldChatLen = gameState.chat.length;
                    gameState = data;
                    determinePlayerColor();
                    renderPieces();
                    updateUI();
                    renderChat();
                    checkUndoRequest();
                    
                    // æ’­æ”¾æ–°æ¶ˆæ¯æç¤º
                    if (gameState.chat.length > oldChatLen) {
                        const lastMsg = gameState.chat[gameState.chat.length - 1];
                        if (lastMsg.playerId !== myPlayerId && lastMsg.sender !== 'system') {
                            playSound('move'); // ç”¨èµ°æ£‹éŸ³ä»£æ›¿æ¶ˆæ¯éŸ³
                        }
                    }
                }
                
                updateConnectionStatus(true);
            } catch (err) {
                console.error('Load error:', err);
                updateConnectionStatus(false);
                if (gameState.board.length === 0) {
                    initBoard();
                }
            }
        }
        
        async function saveGame() {
            if (isSyncing) return;
            isSyncing = true;
            updateConnectionStatus(true, true);
            
            try {
                const response = await fetch(GIST_API, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/vnd.github.v3+json',
                        'Authorization': `token ${GITHUB_TOKEN}`
                    },
                    body: JSON.stringify({
                        files: {
                            'chess-game.json': {
                                content: JSON.stringify(gameState, null, 2)
                            }
                        }
                    })
                });
                
                if (!response.ok) throw new Error('Failed to save');
                
                updateConnectionStatus(true);
            } catch (err) {
                console.error('Save error:', err);
                showToast('ä¿å­˜å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ');
                updateConnectionStatus(false);
            } finally {
                isSyncing = false;
            }
        }
        
        function startSync() {
            syncInterval = setInterval(loadGame, 2000); // æ¯2ç§’åŒæ­¥ä¸€æ¬¡
        }
        
        function determinePlayerColor() {
            if (myColor) return;
            
            if (!gameState.players.red) {
                gameState.players.red = myPlayerId;
                myColor = 'red';
                showToast('ä½ æ˜¯çº¢æ–¹ï¼å…ˆèµ°');
            } else if (!gameState.players.black && gameState.players.red !== myPlayerId) {
                gameState.players.black = myPlayerId;
                myColor = 'black';
                showToast('ä½ æ˜¯é»‘æ–¹ï¼ç­‰å¾…çº¢æ–¹èµ°æ£‹');
            } else if (gameState.players.red === myPlayerId) {
                myColor = 'red';
            } else if (gameState.players.black === myPlayerId) {
                myColor = 'black';
            }
            
            if (myColor) {
                const badge = document.getElementById('playerRole');
                badge.textContent = myColor === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹';
                badge.className = `player-badge ${myColor}`;
            }
        }
        
        function updateConnectionStatus(connected, syncing = false) {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            
            if (syncing) {
                dot.className = 'status-dot syncing';
                text.textContent = 'åŒæ­¥ä¸­...';
            } else if (connected) {
                dot.className = 'status-dot connected';
                text.textContent = 'å·²è¿æ¥';
            } else {
                dot.className = 'status-dot';
                text.textContent = 'æœªè¿æ¥';
            }
        }
        
        // ==================== åˆå§‹åŒ–æ£‹ç›˜ ====================
        function initBoard(save = true) {
            gameState.board = [
                ['R','N','B','A','K','A','B','N','R'],
                ['.','.','.','.','.','.','.','.','.'],
                ['.','C','.','.','.','.','.','C','.'],
                ['P','.','P','.','P','.','P','.','P'],
                ['.','.','.','.','.','.','.','.','.'],
                ['.','.','.','.','.','.','.','.','.'],
                ['p','.','p','.','p','.','p','.','p'],
                ['.','c','.','.','.','.','.','c','.'],
                ['.','.','.','.','.','.','.','.','.'],
                ['r','n','b','a','k','a','b','n','r']
            ];
            gameState.turn = 'red';
            gameState.lastMove = null;
            gameState.moveCount = 0;
            gameState.moves = [];
            gameState.status = 'playing';
            gameState.timers = { red: 600, black: 600 };
            gameState.timerRunning = false;
            gameState.undoRequest = null;
            gameState.timestamp = Date.now();
            
            if (!gameState.chat) gameState.chat = [];
            
            determinePlayerColor();
            renderPieces();
            updateUI();
            renderChat();
            checkUndoRequest();
            
            if (save) saveGame();
        }
        
        // ==================== æŒ‰é’®åŠŸèƒ½ ====================
        function copyGameLink() {
            const url = window.location.href;
            navigator.clipboard.writeText(url).then(() => {
                showToast('é“¾æ¥å·²å¤åˆ¶ï¼Œåˆ†äº«ç»™å§¥çˆ·å§ï¼');
            });
        }
        
        function resign() {
            if (!confirm('ç¡®å®šè¦è®¤è¾“å—ï¼Ÿ')) return;
            
            const winner = myColor === 'red' ? 'é»‘æ–¹' : 'çº¢æ–¹';
            showToast(`ä½ è®¤è¾“äº†ï¼Œ${winner}è·èƒœï¼`);
            gameState.status = 'finished';
            gameState.timerRunning = false;
            
            gameState.chat.push({
                sender: 'system',
                text: `${myColor === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹'}è®¤è¾“ï¼Œ${winner}è·èƒœï¼`,
                time: Date.now()
            });
            
            playSound('win');
            saveGame();
            renderChat();
        }
        
        async function resetGame() {
            if (!confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹å—ï¼Ÿ')) return;
            
            gameState.players = { red: null, black: null };
            myColor = null;
            initBoard(false);
            
            gameState.chat.push({
                sender: 'system',
                text: 'æ–°æ¸¸æˆå¼€å§‹äº†ï¼',
                time: Date.now()
            });
            
            await saveGame();
            showToast('æ–°æ¸¸æˆå·²å¼€å§‹ï¼');
            renderChat();
        }
        
        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }
        
        // ==================== å¯åŠ¨ ====================
        window.onload = init;
    </script>
</body>
</html>'''

