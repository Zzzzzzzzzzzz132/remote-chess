<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿œç¨‹è±¡æ£‹ - ä¸å§¥çˆ·å¯¹å¼ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: "Microsoft YaHei", "SimSun", sans-serif;
            background: linear-gradient(135deg, #f5f5dc 0%, #e8dcc0 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            color: #8b4513;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            font-size: 1.1em;
        }
        
        .game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1200px;
            width: 100%;
        }
        
        .board-wrapper {
            position: relative;
            background: #f0d9b5;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 3px solid #8b4513;
        }
        
        .board {
            width: 450px;
            height: 500px;
            position: relative;
            background: #f0d9b5;
        }
        
        .board-lines {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .horizontal-lines, .vertical-lines {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .horizontal-line {
            position: absolute;
            width: 100%;
            height: 1px;
            background: #333;
        }
        
        .vertical-line {
            position: absolute;
            width: 1px;
            height: 100%;
            background: #333;
        }
        
        .palace-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* ä¿®å¤ä¹å®«æ ¼æ–œçº¿æ ·å¼ - é‡æ–°è®¡ç®—åæ ‡å’Œé•¿åº¦ */
        .palace-line {
            position: absolute;
            width: 142px;
            height: 1px;
            background: #333;
            transform-origin: left center;
        }
        /* ä¸Šæ–¹ä¹å®«æ ¼ï¼ˆé»‘æ–¹ï¼‰æ–œçº¿ */
        .palace-line.top-left { top: 100px; left: 154px; transform: rotate(45deg); }
        .palace-line.top-right { top: 100px; left: 254px; transform: rotate(-45deg); }
        /* ä¸‹æ–¹ä¹å®«æ ¼ï¼ˆçº¢æ–¹ï¼‰æ–œçº¿ */
        .palace-line.bottom-left { top: 400px; left: 154px; transform: rotate(-45deg); }
        .palace-line.bottom-right { top: 400px; left: 254px; transform: rotate(45deg); }
        
        .river {
            position: absolute;
            top: 225px;
            left: 0;
            width: 100%;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #8b4513;
            font-weight: bold;
            letter-spacing: 20px;
        }
        
        .pieces-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .piece {
            position: absolute;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            z-index: 10;
        }
        
        .piece.red {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #cc0000);
            color: #ffeb3b;
            border: 2px solid #8b0000;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .piece.black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            color: #fff;
            border: 2px solid #333;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .piece:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255,215,0,0.8);
        }
        
        .piece.selected {
            box-shadow: 0 0 20px #ffd700, 0 0 40px #ffd700;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1.1); }
            50% { transform: scale(1.2); }
        }
        
        .piece.last-move {
            border: 3px solid #00ff00;
        }
        
        .piece.check {
            animation: check-pulse 0.5s infinite;
            box-shadow: 0 0 20px #ff0000;
        }
        
        @keyframes check-pulse {
            0%, 100% { box-shadow: 0 0 20px #ff0000; }
            50% { box-shadow: 0 0 40px #ff0000, 0 0 60px #ff0000; }
        }
        
        .move-hint {
            position: absolute;
            width: 16px;
            height: 16px;
            background: rgba(0,255,0,0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
        }
        
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 320px;
        }
        
        .panel-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            border: 2px solid #8b4513;
        }
        
        .section-title {
            font-weight: bold;
            color: #8b4513;
            margin-bottom: 15px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* è®¡æ—¶å™¨æ ·å¼ */
        .timer-box {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
        }
        
        .timer {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background: #f5f5f5;
            min-width: 80px;
        }
        
        .timer.active {
            background: #e3f2fd;
            border: 2px solid #2196f3;
        }
        
        .timer-label {
            font-size: 0.8em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .timer-time {
            font-size: 1.5em;
            font-weight: bold;
            font-family: monospace;
        }
        
        .timer.red .timer-time { color: #c62828; }
        .timer.black .timer-time { color: #333; }
        
        /* çŠ¶æ€æ¡† */
        .status-content {
            color: #333;
            line-height: 1.6;
        }
        
        .player-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .player-badge.red {
            background: #ffeb3b;
            color: #c62828;
        }
        
        .player-badge.black {
            background: #333;
            color: #fff;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }
        
        .btn-primary {
            background: #8b4513;
            color: white;
        }
        
        .btn-primary:hover {
            background: #6b3410;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: #e0e0e0;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #d0d0d0;
        }
        
        .btn-danger {
            background: #c62828;
            color: white;
        }
        
        .btn-danger:hover {
            background: #a02020;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* èŠå¤©æ¡† */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 250px;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            background: #f9f9f9;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
        }
        
        .chat-message {
            margin-bottom: 8px;
            padding: 6px 10px;
            border-radius: 12px;
            max-width: 85%;
            word-wrap: break-word;
            font-size: 0.9em;
        }
        
        .chat-message.own {
            background: #dcf8c6;
            margin-left: auto;
            text-align: right;
        }
        
        .chat-message.other {
            background: #fff;
            border: 1px solid #e0e0e0;
        }
        
        .chat-message.system {
            background: #fff3cd;
            text-align: center;
            font-size: 0.8em;
            color: #856404;
            max-width: 100%;
        }
        
        .chat-sender {
            font-size: 0.75em;
            color: #666;
            margin-bottom: 2px;
        }
        
        .chat-input-area {
            display: flex;
            gap: 8px;
        }
        
        .chat-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
            font-family: inherit;
        }
        
        .chat-send {
            padding: 8px 16px;
            background: #8b4513;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
        }
        
        .chat-send:hover {
            background: #6b3410;
        }
        
        /* èµ°æ£‹è®°å½• */
        .moves-list {
            max-height: 150px;
            overflow-y: auto;
            background: #f9f9f9;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9em;
        }
        
        .move-item {
            padding: 4px 0;
            border-bottom: 1px solid #eee;
            color: #555;
            display: flex;
            justify-content: space-between;
        }
        
        .move-number {
            color: #999;
            min-width: 30px;
        }
        
        .move-red { color: #c62828; }
        .move-black { color: #333; }
        
        /* æ‚”æ£‹è¯·æ±‚ */
        .undo-request {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
        }
        
        .undo-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .undo-buttons .btn {
            margin: 0;
            flex: 1;
            padding: 8px;
            font-size: 14px;
        }
        
        /* è¿æ¥çŠ¶æ€ */
        .connection-status {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 0.85em;
            margin-top: 10px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ccc;
        }
        
        .status-dot.connected {
            background: #4caf50;
            animation: blink 2s infinite;
        }
        
        .status-dot.syncing {
            background: #ff9800;
            animation: blink 0.5s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* è®¾ç½® */
        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 10px 0;
        }
        
        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
            background: #ccc;
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle.active {
            background: #4caf50;
        }
        
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        
        .toggle.active .toggle-slider {
            transform: translateX(24px);
        }
        
        /* Toast */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        .toast.show {
            opacity: 1;
        }
        
        @media (max-width: 800px) {
            .board {
                width: 360px;
                height: 400px;
            }
            .piece {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            .side-panel {
                width: 100%;
            }
            /* é€‚é…ç§»åŠ¨ç«¯ä¹å®«æ ¼ */
            .palace-line {
                width: 114px;
            }
            .palace-line.top-left { top: 80px; left: 123px; }
            .palace-line.top-right { top: 80px; left: 203px; }
            .palace-line.bottom-left { top: 320px; left: 123px; }
            .palace-line.bottom-right { top: 320px; left: 203px; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ® è¿œç¨‹è±¡æ£‹ ğŸ®</h1>
        <p class="subtitle">ä¸å§¥çˆ·éš”ç©ºå¯¹å¼ˆï¼Œè·¨è¶Šä¸‡é‡Œçš„äº²æƒ…</p>
    </div>
    
    <div class="game-container">
        <div class="board-wrapper">
            <div class="board" id="board">
                <div class="board-lines">
                    <div class="horizontal-lines" id="hLines"></div>
                    <div class="vertical-lines" id="vLines"></div>
                    <div class="palace-lines">
                        <div class="palace-line top-left"></div>
                        <div class="palace-line top-right"></div>
                        <div class="palace-line bottom-left"></div>
                        <div class="palace-line bottom-right"></div>
                    </div>
                </div>
                <div class="river">æ¥š æ²³ æ±‰ ç•Œ</div>
                <div class="pieces-container" id="piecesContainer"></div>
            </div>
        </div>
        
        <div class="side-panel">
            <!-- è®¡æ—¶å™¨ -->
            <div class="panel-section">
                <div class="section-title">â±ï¸ è®¡æ—¶å™¨</div>
                <div class="timer-box">
                    <div class="timer red" id="timerRed">
                        <div class="timer-label">çº¢æ–¹</div>
                        <div class="timer-time" id="timeRed">10:00</div>
                    </div>
                    <div class="timer black" id="timerBlack">
                        <div class="timer-label">é»‘æ–¹</div>
                        <div class="timer-time" id="timeBlack">10:00</div>
                    </div>
                </div>
            </div>
            
            <!-- æ¸¸æˆçŠ¶æ€ -->
            <div class="panel-section">
                <div class="section-title">ğŸ® æ¸¸æˆçŠ¶æ€</div>
                <div class="status-content">
                    <div>å½“å‰å›åˆ: <span id="currentTurn" style="font-weight:bold;">çº¢æ–¹</span></div>
                    <div>ä½ æ˜¯: <span id="playerRole" class="player-badge">ç­‰å¾…åŠ å…¥...</span></div>
                    <div class="connection-status">
                        <span class="status-dot" id="statusDot"></span>
                        <span id="statusText">è¿æ¥ä¸­...</span>
                    </div>
                </div>
                <div id="undoRequestArea" style="display:none;"></div>
            </div>
            
            <!-- èŠå¤© -->
            <div class="panel-section">
                <div class="section-title">ğŸ’¬ èŠå¤©</div>
                <div class="chat-container">
                    <div class="chat-messages" id="chatMessages">
                        <div class="chat-message system">æ¬¢è¿æ¥åˆ°è¿œç¨‹è±¡æ£‹ï¼å‘é€æ¶ˆæ¯ç»™å¯¹æ–¹...</div>
                    </div>
                    <div class="chat-input-area">
                        <input type="text" class="chat-input" id="chatInput" placeholder="è¾“å…¥æ¶ˆæ¯..." maxlength="100">
                        <button class="chat-send" onclick="sendChat()">å‘é€</button>
                    </div>
                </div>
            </div>
            
            <!-- æ“ä½œæŒ‰é’® -->
            <div class="panel-section">
                <div class="section-title">ğŸ›ï¸ æ“ä½œ</div>
                <button class="btn btn-secondary" onclick="copyGameLink()">ğŸ“‹ å¤åˆ¶å¯¹å±€é“¾æ¥</button>
                <button class="btn btn-secondary" id="undoBtn" onclick="requestUndo()">â†©ï¸ è¯·æ±‚æ‚”æ£‹</button>
                <button class="btn btn-danger" onclick="resign()">ğŸ³ï¸ è®¤è¾“</button>
                <button class="btn btn-primary" onclick="resetGame()">ğŸ”„ é‡æ–°å¼€å§‹</button>
            </div>
            
            <!-- è®¾ç½® -->
            <div class="panel-section">
                <div class="section-title">âš™ï¸ è®¾ç½®</div>
                <div class="settings-row">
                    <span>èµ°æ£‹éŸ³æ•ˆ</span>
                    <div class="toggle active" id="soundToggle" onclick="toggleSound()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
            </div>
            
            <!-- èµ°æ£‹è®°å½• -->
            <div class="panel-section">
                <div class="section-title">ğŸ“ èµ°æ£‹è®°å½•</div>
                <div class="moves-list" id="movesList">
                    <div style="color:#999;text-align:center;">æš‚æ— èµ°æ£‹è®°å½•</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>

    <script>
        // ==================== é…ç½® ====================
        const GIST_ID = '932c2d47035c60f134c28cce0b08428e';
        const GIST_API = `https://api.github.com/gists/${GIST_ID}`;
        const GITHUB_TOKEN = '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';
        
        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        let gameState = {
            board: [],
            turn: 'red',
            lastMove: null,
            moveCount: 0,
            timestamp: Date.now(),
            players: { red: null, black: null },
            status: 'waiting',
            moves: [],
            chat: [],
            undoRequest: null,
            timers: { red: 600, black: 600 }, // 10åˆ†é’Ÿ
            timerRunning: false
        };
        
        let myColor = null;
        let selectedPiece = null;
        let myPlayerId = localStorage.getItem('chess_player_id') || generateId();
        let syncInterval = null;
        let isSyncing = false;
        let soundEnabled = true;
        let timerInterval = null;
        let lastTimerUpdate = Date.now();
        
        // éŸ³æ•ˆï¼ˆä½¿ç”¨ Web Audio API ç”Ÿæˆç®€å•éŸ³æ•ˆï¼‰
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        const pieceNames = {
            'R': 'è½¦', 'N': 'é©¬', 'B': 'è±¡', 'A': 'å£«', 'K': 'å°†', 'C': 'ç‚®', 'P': 'å…µ',
            'r': 'è½¦', 'n': 'é©¬', 'b': 'ç›¸', 'a': 'ä»•', 'k': 'å¸…', 'c': 'ç‚®', 'p': 'å’'
        };
        
        // ==================== éŸ³æ•ˆ ====================
        function playSound(type) {
            if (!soundEnabled) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'move':
                    oscillator.frequency.value = 400;
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'capture':
                    oscillator.frequency.value = 200;
                    gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                case 'check':
                    oscillator.frequency.value = 800;
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'win':
                    oscillator.frequency.value = 600;
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.5);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
            }
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundToggle').classList.toggle('active');
            showToast(soundEnabled ? 'éŸ³æ•ˆå·²å¼€å¯' : 'éŸ³æ•ˆå·²å…³é—­');
        }
        
        // ==================== åˆå§‹åŒ– ====================
        function init() {
            localStorage.setItem('chess_player_id', myPlayerId);
            drawBoard();
            initBoard(true); // åˆå§‹åŒ–æ£‹ç›˜
            loadGame();
            startSync();
            startTimer();
            setupChatInput();
            showToast('æ¬¢è¿æ¥åˆ°è¿œç¨‹è±¡æ£‹ï¼');
        }
        
        function generateId() {
            return 'player_' + Math.random().toString(36).substr(2, 9);
        }
        
        function setupChatInput() {
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendChat();
            });
        }
        
        // ==================== è®¡æ—¶å™¨ ====================
        function startTimer() {
            timerInterval = setInterval(() => {
                if (gameState.status !== 'playing' || !gameState.timerRunning) return;
                
                const now = Date.now();
                const delta = Math.floor((now - lastTimerUpdate) / 1000);
                
                if (delta >= 1) {
                    if (gameState.turn === 'red') {
                        gameState.timers.red = Math.max(0, gameState.timers.red - delta);
                    } else {
                        gameState.timers.black = Math.max(0, gameState.timers.black - delta);
                    }
                    
                    if (gameState.timers.red === 0 || gameState.timers.black === 0) {
                        const winner = gameState.timers.red === 0 ? 'é»‘æ–¹' : 'çº¢æ–¹';
                        showToast(`â° æ—¶é—´åˆ°ï¼${winner}è·èƒœï¼`);
                        gameState.status = 'finished';
                        playSound('win');
                    }
                    
                    updateTimerDisplay();
                    lastTimerUpdate = now;
                }
            }, 1000);
        }
        
        function updateTimerDisplay() {
            document.getElementById('timeRed').textContent = formatTime(gameState.timers.red);
            document.getElementById('timeBlack').textContent = formatTime(gameState.timers.black);
            
            document.getElementById('timerRed').classList.toggle('active', 
                gameState.turn === 'red' && gameState.status === 'playing');
            document.getElementById('timerBlack').classList.toggle('active', 
                gameState.turn === 'black' && gameState.status === 'playing');
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        // ==================== èŠå¤© ====================
        function sendChat() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (!message) return;
            
            if (!myColor) {
                showToast('è¯·å…ˆç­‰å¾…åŠ å…¥æ¸¸æˆ');
                return;
            }
            
            const chatMessage = {
                sender: myColor,
                playerId: myPlayerId,
                text: message,
                time: Date.now()
            };
            
            gameState.chat.push(chatMessage);
            input.value = '';
            
            renderChat();
            saveGame();
        }
        
        function renderChat() {
            const container = document.getElementById('chatMessages');
            container.innerHTML = '';
            
            gameState.chat.slice(-50).forEach(msg => {
                const div = document.createElement('div');
                div.className = 'chat-message';
                
                if (msg.sender === 'system') {
                    div.className += ' system';
                    div.textContent = msg.text;
                } else {
                    const isOwn = msg.playerId === myPlayerId;
                    div.className += isOwn ? ' own' : ' other';
                    
                    const sender = document.createElement('div');
                    sender.className = 'chat-sender';
                    sender.textContent = msg.sender === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹';
                    div.appendChild(sender);
                    
                    const text = document.createElement('div');
                    text.textContent = msg.text;
                    div.appendChild(text);
                }
                
                container.appendChild(div);
            });
            
            container.scrollTop = container.scrollHeight;
        }
        
        // ==================== æ‚”æ£‹ ====================
        function requestUndo() {
            if (!myColor || gameState.moves.length === 0) {
                showToast('ç°åœ¨ä¸èƒ½æ‚”æ£‹');
                return;
            }
            
            if (gameState.undoRequest) {
                showToast('å·²ç»æœ‰ä¸€ä¸ªæ‚”æ£‹è¯·æ±‚äº†');
                return;
            }
            
            gameState.undoRequest = {
                requester: myColor,
                moveCount: gameState.moveCount,
                timestamp: Date.now()
            };
            
            saveGame();
            showToast('å·²å‘é€æ‚”æ£‹è¯·æ±‚ï¼Œç­‰å¾…å¯¹æ–¹åŒæ„');
            checkUndoRequest();
        }
        
        function checkUndoRequest() {
            const area = document.getElementById('undoRequestArea');
            
            if (!gameState.undoRequest) {
                area.style.display = 'none';
                area.innerHTML = '';
                return;
            }
            
            const isRequester = gameState.undoRequest.requester === myColor;
            
            if (isRequester) {
                area.style.display = 'block';
                area.innerHTML = '<div style="color:#856404;">ç­‰å¾…å¯¹æ–¹åŒæ„æ‚”æ£‹...</div>';
            } else {
                area.style.display = 'block';
                area.innerHTML = `
                    <div class="undo-request">
                        <div>å¯¹æ–¹è¯·æ±‚æ‚”æ£‹ï¼ˆå›åˆ°ç¬¬${gameState.undoRequest.moveCount}æ­¥ï¼‰</div>
                        <div class="undo-buttons">
                            <button class="btn btn-primary" onclick="acceptUndo()">åŒæ„</button>
                            <button class="btn btn-secondary" onclick="rejectUndo()">æ‹’ç»</button>
                        </div>
                    </div>
                `;
            }
        }
        
        function acceptUndo() {
            // æ‰§è¡Œæ‚”æ£‹ - å›é€€åˆ°æŒ‡å®šæ­¥æ•°
            const targetMove = gameState.undoRequest.moveCount;
            const movesToUndo = gameState.moveCount - targetMove;
            
            // é‡æ–°åˆå§‹åŒ–æ£‹ç›˜
            initBoard(false);
            
            // é‡æ–°æ‰§è¡Œèµ°æ£‹åˆ°ç›®æ ‡æ­¥æ•°
            const movesToReplay = gameState.moves.slice(0, targetMove);
            gameState.moves = [];
            gameState.moveCount = 0;
            
            // å›æ”¾èµ°æ£‹
            movesToReplay.forEach(move => {
                makeMove(move.from.row, move.from.col, move.to.row, move.to.col, true);
            });
            
            gameState.undoRequest = null;
            gameState.chat.push({
                sender: 'system',
                text: `æ‚”æ£‹æˆåŠŸï¼Œå›é€€åˆ°ç¬¬${targetMove}æ­¥`,
                time: Date.now()
            });
            
            saveGame();
            showToast('å·²åŒæ„æ‚”æ£‹');
        }
        
        function rejectUndo() {
            gameState.undoRequest = null;
            gameState.chat.push({
                sender: 'system',
                text: 'æ‚”æ£‹è¯·æ±‚è¢«æ‹’ç»',
                time: Date.now()
            });
            saveGame();
            showToast('å·²æ‹’ç»æ‚”æ£‹è¯·æ±‚');
        }
        
        // ==================== ç»˜åˆ¶æ£‹ç›˜ ====================
        function drawBoard() {
            const hLines = document.getElementById('hLines');
            const vLines = document.getElementById('vLines');
            
            // ç»˜åˆ¶æ¨ªçº¿ (10æ¡)
            for (let i = 0; i < 10; i++) {
                const line = document.createElement('div');
                line.className = 'horizontal-line';
                line.style.top = `${i * 50 + 25}px`;
                hLines.appendChild(line);
            }
            
            // ç»˜åˆ¶ç«–çº¿ (9æ¡)
            for (let i = 0; i < 9; i++) {
                const line = document.createElement('div');
                line.className = 'vertical-line';
                line.style.left = `${i * 50 + 25}px`;
                
                if (i === 0 || i === 8) {
                    line.style.height = '100%';
                } else {
                    // ç«–çº¿è¢«æ¥šæ²³æ±‰ç•Œæ–­å¼€
                    line.style.height = '200px';
                    line.style.top = '25px';
                    
                    const line2 = document.createElement('div');
                    line2.className = 'vertical-line';
                    line2.style.left = `${i * 50 + 25}px`;
                    line2.style.height = '200px';
                    line2.style.top = '275px';
                    vLines.appendChild(line2);
                }
                vLines.appendChild(line);
            }
        }
        
        // ==================== æ£‹ç›˜åˆå§‹åŒ– ====================
        function initBoard(initial = true) {
            // åˆå§‹åŒ–ç©ºæ£‹ç›˜
            gameState.board = Array(10).fill().map(() => Array(9).fill('.'));
            
            // é»‘æ–¹æ£‹å­ (å¤§å†™) - ä¸Šæ–¹
            gameState.board[0][0] = 'R'; // è½¦
            gameState.board[0][1] = 'N'; // é©¬
            gameState.board[0][2] = 'B'; // è±¡
            gameState.board[0][3] = 'A'; // å£«
            gameState.board[0][4] = 'K'; // å°†
            gameState.board[0][5] = 'A'; // å£«
            gameState.board[0][6] = 'B'; // è±¡
            gameState.board[0][7] = 'N'; // é©¬
            gameState.board[0][8] = 'R'; // è½¦
            gameState.board[2][1] = 'C'; // ç‚®
            gameState.board[2][7] = 'C'; // ç‚®
            gameState.board[3][0] = 'P'; // å…µ
            gameState.board[3][2] = 'P'; // å…µ
            gameState.board[3][4] = 'P'; // å…µ
            gameState.board[3][6] = 'P'; // å…µ
            gameState.board[3][8] = 'P'; // å…µ
            
            // çº¢æ–¹æ£‹å­ (å°å†™) - ä¸‹æ–¹
            gameState.board[9][0] = 'r'; // è½¦
            gameState.board[9][1] = 'n'; // é©¬
            gameState.board[9][2] = 'b'; // ç›¸
            gameState.board[9][3] = 'a'; // ä»•
            gameState.board[9][4] = 'k'; // å¸…
            gameState.board[9][5] = 'a'; // ä»•
            gameState.board[9][6] = 'b'; // ç›¸
            gameState.board[9][7] = 'n'; // é©¬
            gameState.board[9][8] = 'r'; // è½¦
            gameState.board[7][1] = 'c'; // ç‚®
            gameState.board[7][7] = 'c'; // ç‚®
            gameState.board[6][0] = 'p'; // å’
            gameState.board[6][2] = 'p'; // å’
            gameState.board[6][4] = 'p'; // å’
            gameState.board[6][6] = 'p'; // å’
            gameState.board[6][8] = 'p'; // å’
            
            if (initial) {
                gameState.moveCount = 0;
                gameState.moves = [];
                gameState.lastMove = null;
                gameState.turn = 'red'; // çº¢æ–¹å…ˆè¡Œ
                document.getElementById('currentTurn').textContent = 'çº¢æ–¹';
            }
            
            renderPieces();
            updateGameStatus();
        }
        
        // ==================== æ£‹å­æ“ä½œæ ¸å¿ƒé€»è¾‘ ====================
        function renderPieces() {
            const container = document.getElementById('piecesContainer');
            container.innerHTML = '';
            
            if (!gameState.board || gameState.board.length === 0) return;
            
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece !== '.') {
                        const el = document.createElement('div');
                        // ä¿®å¤æ£‹å­é¢œè‰²åˆ¤æ–­ï¼šå°å†™=çº¢æ–¹ï¼Œå¤§å†™=é»‘æ–¹
                        el.className = `piece ${piece === piece.toLowerCase() ? 'red' : 'black'}`;
                        el.textContent = pieceNames[piece];
                        el.style.left = `${col * 50 + 3}px`;
                        el.style.top = `${row * 50 + 3}px`;
                        
                        if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                            el.classList.add('selected');
                        }
                        
                        if (gameState.lastMove) {
                            const [from, to] = [gameState.lastMove.from, gameState.lastMove.to];
                            if ((row === from.row && col === from.col) || 
                                (row === to.row && col === to.col)) {
                                el.classList.add('last-move');
                            }
                        }
                        
                        // æ£€æŸ¥æ˜¯å¦è¢«å°†å†›
                        if (piece.toUpperCase() === 'K' && isInCheck(piece === piece.toLowerCase())) {
                            el.classList.add('check');
                        }
                        
                        el.onclick = () => onPieceClick(row, col);
                        container.appendChild(el);
                    }
                }
            }
            
            if (selectedPiece) {
                showMoveHints(selectedPiece.row, selectedPiece.col);
            }
        }
        
        function showMoveHints(row, col) {
            const container = document.getElementById('piecesContainer');
            const piece = gameState.board[row][col];
            if (!piece || piece === '.') return;
            
            const isRed = piece === piece.toLowerCase();
            // éªŒè¯å½“å‰ç©å®¶æ˜¯å¦èƒ½æ“ä½œè¯¥æ£‹å­
            if ((isRed && myColor !== 'red') || (!isRed && myColor !== 'black')) return;
            if ((isRed && gameState.turn !== 'red') || (!isRed && gameState.turn !== 'black')) return;
            
            // æ˜¾ç¤ºæ‰€æœ‰åˆæ³•ç§»åŠ¨æç¤º
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const hint = document.createElement('div');
                        hint.className = 'move-hint';
                        hint.style.left = `${c * 50 + 25}px`;
                        hint.style.top = `${r * 50 + 25}px`;
                        hint.onclick = () => onHintClick(r, c);
                        container.appendChild(hint);
                    }
                }
            }
        }
        
        function onPieceClick(row, col) {
            const piece = gameState.board[row][col];
            
            // ç©ºä½ç½® - å°è¯•ç§»åŠ¨é€‰ä¸­çš„æ£‹å­
            if (!piece || piece === '.') {
                if (selectedPiece) {
                    if (isValidMove(selectedPiece.row, selectedPiece.col, row, col)) {
                        makeMove(selectedPiece.row, selectedPiece.col, row, col);
                        selectedPiece = null;
                    } else {
                        showToast('æ— æ•ˆçš„ç§»åŠ¨ï¼');
                        selectedPiece = null;
                    }
                }
                renderPieces();
                return;
            }
            
            const isRed = piece === piece.toLowerCase();
            
            // æœªåŠ å…¥æ¸¸æˆ
            if (myColor === null) {
                showToast('è¯·å…ˆåŠ å…¥æ¸¸æˆï¼');
                return;
            }
            
            // ä¸æ˜¯è‡ªå·±çš„æ£‹å­
            if ((isRed && myColor !== 'red') || (!isRed && myColor !== 'black')) {
                showToast('è¿™æ˜¯å¯¹æ–¹çš„æ£‹å­ï¼');
                selectedPiece = null;
                renderPieces();
                return;
            }
            
            // ä¸æ˜¯è‡ªå·±çš„å›åˆ
            if ((isRed && gameState.turn !== 'red') || (!isRed && gameState.turn !== 'black')) {
                showToast('è¿˜æ²¡åˆ°ä½ çš„å›åˆï¼');
                selectedPiece = null;
                renderPieces();
                return;
            }
            
            // é€‰ä¸­è‡ªå·±çš„æ£‹å­
            selectedPiece = { row, col, piece };
            renderPieces();
        }
        
        function onHintClick(row, col) {
            if (selectedPiece) {
                makeMove(selectedPiece.row, selectedPiece.col, row, col);
                selectedPiece = null;
                renderPieces();
            }
        }
        
        // éªŒè¯ç§»åŠ¨æ˜¯å¦åˆæ³•
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            // ç›¸åŒä½ç½®
            if (fromRow === toRow && fromCol === toCol) return false;
            
            const piece = gameState.board[fromRow][fromCol];
            const targetPiece = gameState.board[toRow][toCol];
            
            // ç›®æ ‡ä½ç½®æ˜¯è‡ªå·±çš„æ£‹å­
            if (targetPiece && targetPiece !== '.') {
                const isRedPiece = piece === piece.toLowerCase();
                const isRedTarget = targetPiece === targetPiece.toLowerCase();
                if (isRedPiece === isRedTarget) return false;
            }
            
            // æ ¹æ®æ£‹å­ç±»å‹éªŒè¯ç§»åŠ¨è§„åˆ™
            switch(piece.toUpperCase()) {
                case 'R': // è½¦
                    return isValidRookMove(fromRow, fromCol, toRow, toCol);
                case 'N': // é©¬
                    return isValidKnightMove(fromRow, fromCol, toRow, toCol);
                case 'B': // è±¡/ç›¸
                    return isValidBishopMove(fromRow, fromCol, toRow, toCol);
                case 'A': // å£«/ä»•
                    return isValidAdvisorMove(fromRow, fromCol, toRow, toCol);
                case 'K': // å°†/å¸…
                    return isValidKingMove(fromRow, fromCol, toRow, toCol);
                case 'C': // ç‚®
                    return isValidCannonMove(fromRow, fromCol, toRow, toCol);
                case 'P': // å…µ/å’
                    return isValidPawnMove(fromRow, fromCol, toRow, toCol);
                default:
                    return false;
            }
        }
        
        // è½¦çš„ç§»åŠ¨è§„åˆ™
        function isValidRookMove(fromRow, fromCol, toRow, toCol) {
            // è½¦èµ°ç›´çº¿
            if (fromRow !== toRow && fromCol !== toCol) return false;
            
            // æ£€æŸ¥è·¯å¾„æ˜¯å¦æœ‰é˜»æŒ¡
            if (fromRow === toRow) {
                // æ¨ªå‘ç§»åŠ¨
                const minCol = Math.min(fromCol, toCol);
                const maxCol = Math.max(fromCol, toCol);
                for (let col = minCol + 1; col < maxCol; col++) {
                    if (gameState.board[fromRow][col] !== '.') return false;
                }
            } else {
                // çºµå‘ç§»åŠ¨
                const minRow = Math.min(fromRow, toRow);
                const maxRow = Math.max(fromRow, toRow);
                for (let row = minRow + 1; row < maxRow; row++) {
                    if (gameState.board[row][fromCol] !== '.') return false;
                }
            }
            
            return true;
        }
        
        // é©¬çš„ç§»åŠ¨è§„åˆ™ (èµ°æ—¥)
        function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
            const rowDiff = Math.abs(fromRow - toRow);
            const colDiff = Math.abs(fromCol - toCol);
            
            // å¿…é¡»æ˜¯æ—¥å­—
            if (!((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2))) return false;
            
            // æ£€æŸ¥ç»Šé©¬è…¿
            if (rowDiff === 2) {
                const midRow = fromRow + (toRow - fromRow) / 2;
                if (gameState.board[midRow][fromCol] !== '.') return false;
            } else {
                const midCol = fromCol + (toCol - fromCol) / 2;
                if (gameState.board[fromRow][midCol] !== '.') return false;
            }
            
            return true;
        }
        
        // è±¡/ç›¸çš„ç§»åŠ¨è§„åˆ™
        function isValidBishopMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const isRed = piece === piece.toLowerCase();
            
            // è±¡èµ°ç”°
            const rowDiff = Math.abs(fromRow - toRow);
            const colDiff = Math.abs(fromCol - toCol);
            if (rowDiff !== 2 || colDiff !== 2) return false;
            
            // çº¢ç›¸ä¸è¿‡æ²³ï¼Œé»‘è±¡ä¸è¿‡æ²³
            if (isRed && toRow < 5) return false;
            if (!isRed && toRow > 4) return false;
            
            // æ£€æŸ¥å¡è±¡çœ¼
            const midRow = (fromRow + toRow) / 2;
            const midCol = (fromCol + toCol) / 2;
            if (gameState.board[midRow][midCol] !== '.') return false;
            
            return true;
        }
        
        // å£«/ä»•çš„ç§»åŠ¨è§„åˆ™
        function isValidAdvisorMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const isRed = piece === piece.toLowerCase();
            
            // å¿…é¡»åœ¨ä¹å®«å†…
            const isInPalace = (row, col) => {
                if (isRed) {
                    return row >= 7 && row <= 9 && col >= 3 && col <= 5;
                } else {
                    return row >= 0 && row <= 2 && col >= 3 && col <= 5;
                }
            };
            
            if (!isInPalace(toRow, toCol)) return false;
            
            // å£«èµ°æ–œçº¿ä¸€æ­¥
            const rowDiff = Math.abs(fromRow - toRow);
            const colDiff = Math.abs(fromCol - toCol);
            return rowDiff === 1 && colDiff === 1;
        }
        
        // å°†/å¸…çš„ç§»åŠ¨è§„åˆ™
        function isValidKingMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const isRed = piece === piece.toLowerCase();
            
            // å¿…é¡»åœ¨ä¹å®«å†…
            const isInPalace = (row, col) => {
                if (isRed) {
                    return row >= 7 && row <= 9 && col >= 3 && col <= 5;
                } else {
                    return row >= 0 && row <= 2 && col >= 3 && col <= 5;
                }
            };
            
            if (!isInPalace(toRow, toCol)) return false;
            
            // å°†èµ°ç›´çº¿ä¸€æ­¥
            const rowDiff = Math.abs(fromRow - toRow);
            const colDiff = Math.abs(fromCol - toCol);
            return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
        }
        
        // ç‚®çš„ç§»åŠ¨è§„åˆ™ - ä¿®å¤ç¿»å±±æ‰“å­é€»è¾‘
        function isValidCannonMove(fromRow, fromCol, toRow, toCol) {
            const targetPiece = gameState.board[toRow][toCol];
            
            // ç‚®èµ°ç›´çº¿
            if (fromRow !== toRow && fromCol !== toCol) return false;
            
            // ç»Ÿè®¡è·¯å¾„ä¸Šçš„æ£‹å­æ•°é‡
            let obstacleCount = 0;
            let obstacles = [];
            
            if (fromRow === toRow) {
                // æ¨ªå‘ç§»åŠ¨
                const minCol = Math.min(fromCol, toCol);
                const maxCol = Math.max(fromCol, toCol);
                for (let col = minCol + 1; col < maxCol; col++) {
                    if (gameState.board[fromRow][col] !== '.') {
                        obstacleCount++;
                        obstacles.push(gameState.board[fromRow][col]);
                    }
                }
            } else {
                // çºµå‘ç§»åŠ¨
                const minRow = Math.min(fromRow, toRow);
                const maxRow = Math.max(fromRow, toRow);
                for (let row = minRow + 1; row < maxRow; row++) {
                    if (gameState.board[row][fromCol] !== '.') {
                        obstacleCount++;
                        obstacles.push(gameState.board[row][fromCol]);
                    }
                }
            }
            
            // ç‚®çš„ç§»åŠ¨è§„åˆ™ï¼š
            // 1. ä¸åƒå­ï¼šè·¯å¾„ä¸Šæ— æ£‹å­
            // 2. åƒå­ï¼šè·¯å¾„ä¸Šå¿…é¡»æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªæ£‹å­ï¼ˆç¿»å±±ï¼‰ï¼Œä¸”ç›®æ ‡ä½ç½®æ˜¯å¯¹æ–¹æ£‹å­
            if (!targetPiece || targetPiece === '.') {
                // ä¸åƒå­
                return obstacleCount === 0;
            } else {
                // åƒå­ - å¿…é¡»ç¿»å±±ä¸”ç›®æ ‡æ˜¯å¯¹æ–¹æ£‹å­
                if (obstacleCount !== 1) return false;
                
                // éªŒè¯ç›®æ ‡æ˜¯å¯¹æ–¹æ£‹å­
                const isRedCannon = gameState.board[fromRow][fromCol] === gameState.board[fromRow][fromCol].toLowerCase();
                const isRedTarget = targetPiece === targetPiece.toLowerCase();
                return isRedCannon !== isRedTarget;
            }
        }
        
        // å…µ/å’çš„ç§»åŠ¨è§„åˆ™
        function isValidPawnMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const isRed = piece === piece.toLowerCase();
            const rowDiff = toRow - fromRow;
            const colDiff = Math.abs(fromCol - toCol);
            
            // æœªè¿‡æ²³ï¼šåªèƒ½å‰è¿›
            if ((isRed && fromRow > 4) || (!isRed && fromRow < 5)) {
                // çº¢å…µæœªè¿‡æ²³ï¼šå‘ä¸Šèµ°ï¼ˆè¡Œå·å‡å°ï¼‰
                if (isRed) {
                    if (rowDiff !== -1 || colDiff !== 0) return false;
                } 
                // é»‘å’æœªè¿‡æ²³ï¼šå‘ä¸‹èµ°ï¼ˆè¡Œå·å¢å¤§ï¼‰
                else {
                    if (rowDiff !== 1 || colDiff !== 0) return false;
                }
            } 
            // å·²è¿‡æ²³ï¼šå¯ä»¥å‰è¿›æˆ–å·¦å³ç§»åŠ¨
            else {
                if (colDiff > 0 && rowDiff !== 0) return false; // ä¸èƒ½æ–œç€èµ°
                if (colDiff > 1 || Math.abs(rowDiff) > 1) return false; // åªèƒ½èµ°ä¸€æ­¥
                
                // å‰è¿›æ–¹å‘éªŒè¯
                if (rowDiff !== 0) {
                    if (isRed && rowDiff !== -1) return false; // çº¢å…µå‘ä¸Š
                    if (!isRed && rowDiff !== 1) return false; // é»‘å’å‘ä¸‹
                }
            }
            
            return true;
        }
        
        // æ‰§è¡Œç§»åŠ¨
        function makeMove(fromRow, fromCol, toRow, toCol, replay = false) {
            const piece = gameState.board[fromRow][fromCol];
            const targetPiece = gameState.board[toRow][toCol];
            
            // è®°å½•ç§»åŠ¨
            const move = {
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                piece: piece,
                captured: targetPiece || null,
                timestamp: Date.now()
            };
            
            // æ‰§è¡Œç§»åŠ¨
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = '.';
            
            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            gameState.lastMove = move;
            gameState.moves.push(move);
            gameState.moveCount++;
            
            // æ’­æ”¾éŸ³æ•ˆ
            if (!replay) {
                if (targetPiece && targetPiece !== '.') {
                    playSound('capture');
                } else {
                    playSound('move');
                }
                
                // æ£€æŸ¥å°†å†›
                const isRedTurn = gameState.turn === 'red';
                if (isInCheck(!isRedTurn)) {
                    playSound('check');
                    showToast(isRedTurn ? 'é»‘æ–¹è¢«å°†å†›ï¼' : 'çº¢æ–¹è¢«å°†å†›ï¼');
                }
            }
            
            // åˆ‡æ¢å›åˆ
            gameState.turn = gameState.turn === 'red' ? 'black' : 'red';
            document.getElementById('currentTurn').textContent = gameState.turn === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹';
            
            // æ›´æ–°UI
            renderPieces();
            updateMovesList();
            updateTimerDisplay();
            
            // ä¿å­˜æ¸¸æˆçŠ¶æ€
            if (!replay) {
                saveGame();
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦è¢«å°†å†›
        function isInCheck(isRed) {
            // æ‰¾åˆ°å°†/å¸…çš„ä½ç½®
            let kingPos = null;
            const kingChar = isRed ? 'k' : 'K';
            
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    if (gameState.board[row][col] === kingChar) {
                        kingPos = { row, col };
                        break;
                    }
                }
                if (kingPos) break;
            }
            
            if (!kingPos) return false;
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å¯¹æ–¹æ£‹å­èƒ½æ”»å‡»åˆ°å°†/å¸…
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = gameState.board[row][col];
                    if (piece === '.' || piece === kingChar) continue;
                    
                    const isRedPiece = piece === piece.toLowerCase();
                    if (isRedPiece === isRed) continue; // è·³è¿‡å·±æ–¹æ£‹å­
                    
                    if (isValidMove(row, col, kingPos.row, kingPos.col)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // ==================== æ¸¸æˆçŠ¶æ€ç®¡ç† ====================
        function updateMovesList() {
            const container = document.getElementById('movesList');
            container.innerHTML = '';
            
            if (gameState.moves.length === 0) {
                container.innerHTML = '<div style="color:#999;text-align:center;">æš‚æ— èµ°æ£‹è®°å½•</div>';
                return;
            }
            
            // æŒ‰å›åˆåˆ†ç»„æ˜¾ç¤º
            for (let i = 0; i < gameState.moves.length; i += 2) {
                const redMove = gameState.moves[i];
                const blackMove = gameState.moves[i + 1];
                
                const moveItem = document.createElement('div');
                moveItem.className = 'move-item';
                
                const number = document.createElement('div');
                number.className = 'move-number';
                number.textContent = `${Math.floor(i/2) + 1}.`;
                
                const redMoveText = document.createElement('div');
                redMoveText.className = 'move-red';
                redMoveText.textContent = getMoveText(redMove);
                
                const blackMoveText = document.createElement('div');
                blackMoveText.className = 'move-black';
                blackMoveText.textContent = blackMove ? getMoveText(blackMove) : '';
                
                moveItem.appendChild(number);
                moveItem.appendChild(redMoveText);
                moveItem.appendChild(blackMoveText);
                
                container.appendChild(moveItem);
            }
            
            container.scrollTop = container.scrollHeight;
        }
        
        function getMoveText(move) {
            const fromPos = `${String.fromCharCode(97 + move.from.col)}${10 - move.from.row}`;
            const toPos = `${String.fromCharCode(97 + move.to.col)}${10 - move.to.row}`;
            const pieceName = pieceNames[move.piece];
            const captureText = move.captured ? 'åƒ' : 'åˆ°';
            
            return `${pieceName}${fromPos}${captureText}${toPos}`;
        }
        
        function updateGameStatus() {
            // æ›´æ–°ç©å®¶è§’è‰²æ˜¾ç¤º
            const roleElement = document.getElementById('playerRole');
            if (myColor) {
                roleElement.className = `player-badge ${myColor}`;
                roleElement.textContent = myColor === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹';
            } else {
                roleElement.className = 'player-badge';
                roleElement.textContent = 'ç­‰å¾…åŠ å…¥...';
            }
            
            // æ›´æ–°å½“å‰å›åˆ
            document.getElementById('currentTurn').textContent = gameState.turn === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹';
            
            // æ›´æ–°è¿æ¥çŠ¶æ€
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (gameState.status === 'playing') {
                statusDot.className = 'status-dot connected';
                statusText.textContent = 'å·²è¿æ¥ - æ¸¸æˆä¸­';
            } else if (gameState.status === 'waiting') {
                statusDot.className = 'status-dot syncing';
                statusText.textContent = 'ç­‰å¾…å¯¹æ‰‹åŠ å…¥...';
            } else if (gameState.status === 'finished') {
                statusDot.className = 'status-dot connected';
                statusText.textContent = 'æ¸¸æˆç»“æŸ';
            }
            
            // æ£€æŸ¥æ‚”æ£‹è¯·æ±‚
            checkUndoRequest();
        }
        
        // ==================== ç½‘ç»œåŒæ­¥ï¼ˆç®€åŒ–ç‰ˆï¼‰====================
        function startSync() {
            // åŠ å…¥æ¸¸æˆ
            joinGame();
            
            // å®šæœŸåŒæ­¥æ¸¸æˆçŠ¶æ€
            syncInterval = setInterval(() => {
                if (!isSyncing) {
                    syncGameState();
                }
            }, 2000);
        }
        
        function joinGame() {
            // åˆ†é…ç©å®¶é¢œè‰² - ä¿®å¤åŒäººéƒ½æ‰§é»‘é—®é¢˜
            if (!gameState.players.red) {
                myColor = 'red';
                gameState.players.red = myPlayerId;
            } else if (!gameState.players.black) {
                myColor = 'black';
                gameState.players.black = myPlayerId;
            } else {
                // è§‚å¯Ÿè€…æ¨¡å¼
                myColor = null;
                showToast('æ¸¸æˆå·²æ»¡ï¼Œä½ ç°åœ¨æ˜¯è§‚å¯Ÿè€…æ¨¡å¼');
            }
            
            // å¼€å§‹æ¸¸æˆ
            if (gameState.players.red && gameState.players.black) {
                gameState.status = 'playing';
                gameState.timerRunning = true;
                lastTimerUpdate = Date.now();
                gameState.chat.push({
                    sender: 'system',
                    text: 'æ¸¸æˆå¼€å§‹ï¼çº¢æ–¹å…ˆè¡Œ',
                    time: Date.now()
                });
            }
            
            saveGame();
            updateGameStatus();
        }
        
        function syncGameState() {
            isSyncing = true;
            
            // æ¨¡æ‹Ÿä»æœåŠ¡å™¨åŠ è½½æ¸¸æˆçŠ¶æ€ï¼ˆå®é™…é¡¹ç›®ä¸­æ›¿æ¢ä¸ºçœŸå®APIè¯·æ±‚ï¼‰
            setTimeout(() => {
                // æ›´æ–°æœ¬åœ°UI
                renderPieces();
                renderChat();
                updateMovesList();
                updateTimerDisplay();
                updateGameStatus();
                
                isSyncing = false;
            }, 300);
        }
        
        function saveGame() {
            gameState.timestamp = Date.now();
            // å®é™…é¡¹ç›®ä¸­è¿™é‡Œä¼šå‘é€åˆ°Gist API
            localStorage.setItem('chess_game_state', JSON.stringify(gameState));
        }
        
        function loadGame() {
            const savedState = localStorage.getItem('chess_game_state');
            if (savedState) {
                try {
                    gameState = JSON.parse(savedState);
                    // éªŒè¯ç©å®¶ID
                    if (gameState.players.red === myPlayerId) {
                        myColor = 'red';
                    } else if (gameState.players.black === myPlayerId) {
                        myColor = 'black';
                    } else {
                        myColor = null;
                    }
                } catch (e) {
                    console.error('åŠ è½½æ¸¸æˆçŠ¶æ€å¤±è´¥', e);
                    initBoard(true);
                }
            } else {
                initBoard(true);
            }
            
            renderPieces();
            renderChat();
            updateMovesList();
            updateTimerDisplay();
            updateGameStatus();
        }
        
        // ==================== å·¥å…·å‡½æ•° ====================
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        function copyGameLink() {
            // æ¨¡æ‹Ÿå¤åˆ¶é“¾æ¥
            navigator.clipboard.writeText(window.location.href).then(() => {
                showToast('å¯¹å±€é“¾æ¥å·²å¤åˆ¶ï¼');
            }).catch(() => {
                showToast('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ç½‘å€');
            });
        }
        
        function resign() {
            if (!myColor) return;
            
            const winner = myColor === 'red' ? 'é»‘æ–¹' : 'çº¢æ–¹';
            showToast(`${myColor === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹'}è®¤è¾“ï¼Œ${winner}è·èƒœï¼`);
            gameState.status = 'finished';
            gameState.timerRunning = false;
            gameState.chat.push({
                sender: 'system',
                text: `${myColor === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹'}è®¤è¾“ï¼Œ${winner}è·èƒœï¼`,
                time: Date.now()
            });
            
            playSound('win');
            saveGame();
            updateGameStatus();
        }
        
        function resetGame() {
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState = {
                board: [],
                turn: 'red',
                lastMove: null,
                moveCount: 0,
                timestamp: Date.now(),
                players: { red: myPlayerId, black: gameState.players.black },
                status: 'waiting',
                moves: [],
                chat: [],
                undoRequest: null,
                timers: { red: 600, black: 600 },
                timerRunning: false
            };
            
            initBoard(true);
            saveGame();
            showToast('æ¸¸æˆå·²é‡ç½®ï¼');
            updateGameStatus();
        }
        
        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.onload = init;
    </script>
</body>
</html>
