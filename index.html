<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸­å›½è±¡æ£‹ - AIå¯¹æˆ˜2.0</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: "Microsoft YaHei", "SimSun", sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #eee;
        }
        .header { text-align: center; margin-bottom: 20px; }
        h1 { 
            color: #ffd700; 
            font-size: 2.5em; 
            text-shadow: 0 0 20px rgba(255,215,0,0.5);
            margin-bottom: 10px; 
        }
        .subtitle { color: #aaa; font-size: 1.1em; }
        .game-container {
            display: flex; gap: 30px; align-items: flex-start; flex-wrap: wrap;
            justify-content: center; max-width: 1200px; width: 100%;
        }
        .board-wrapper {
            position: relative; background: #f0d9b5; padding: 40px;
            border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 3px solid #8b4513;
        }
        .board { width: 450px; height: 500px; position: relative; background: #f0d9b5; }
        .board-lines { position: absolute; width: 100%; height: 100%; }
        .horizontal-lines, .vertical-lines { position: absolute; width: 100%; height: 100%; }
        .horizontal-line { position: absolute; width: 400px; height: 1px; background: #333; left: 25px; }
        .vertical-line { position: absolute; width: 1px; background: #333; }
        .palace-lines { position: absolute; width: 100%; height: 100%; pointer-events: none; }
        .palace-line { position: absolute; width: 141px; height: 1px; background: #333; transform-origin: left center; }
        .palace-line.top-left { top: 75px; left: 154px; transform: rotate(45deg); }
        .palace-line.top-right { top: 75px; right: 154px; transform: rotate(-45deg); }
        .palace-line.bottom-left { bottom: 75px; left: 154px; transform: rotate(-45deg); }
        .palace-line.bottom-right { bottom: 75px; right: 154px; transform: rotate(45deg); }
        .river {
            position: absolute; top: 225px; left: 0; width: 100%; height: 50px;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; color: #8b4513; font-weight: bold; letter-spacing: 20px;
        }
        .pieces-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .piece {
            position: absolute; width: 44px; height: 44px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; font-weight: bold; cursor: pointer;
            transition: all 0.3s ease; user-select: none; z-index: 10;
        }
        .piece.red {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #cc0000);
            color: #ffeb3b; border: 2px solid #8b0000; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .piece.black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            color: #fff; border: 2px solid #333; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .piece:hover { transform: scale(1.1); box-shadow: 0 0 15px rgba(255,215,0,0.8); }
        .piece.selected { box-shadow: 0 0 20px #ffd700, 0 0 40px #ffd700; animation: pulse 1s infinite; }
        .piece.ai-thinking { animation: ai-pulse 1s infinite; box-shadow: 0 0 20px #00ff00; }
        @keyframes pulse { 0%, 100% { transform: scale(1.1); } 50% { transform: scale(1.2); } }
        @keyframes ai-pulse { 0%, 100% { box-shadow: 0 0 20px #00ff00; } 50% { box-shadow: 0 0 40px #00ff00, 0 0 60px #00ff00; } }
        .piece.last-move { border: 3px solid #00ff00; }
        .piece.check { animation: check-pulse 0.5s infinite; box-shadow: 0 0 20px #ff0000; }
        @keyframes check-pulse { 0%, 100% { box-shadow: 0 0 20px #ff0000; } 50% { box-shadow: 0 0 40px #ff0000, 0 0 60px #ff0000; } }
        .move-hint {
            position: absolute; width: 16px; height: 16px; background: rgba(0,255,0,0.6);
            border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: auto; cursor: pointer; z-index: 5;
        }
        .move-hint:hover { background: rgba(0,255,0,0.9); transform: translate(-50%, -50%) scale(1.3); }
        .side-panel { display: flex; flex-direction: column; gap: 20px; width: 320px; }
        .panel-section {
            background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
        }
        .section-title { font-weight: bold; color: #ffd700; margin-bottom: 15px; font-size: 1.1em; display: flex; align-items: center; gap: 8px; }
        .ai-status { 
            background: rgba(227,242,253,0.1); border: 2px solid #2196f3; border-radius: 8px; 
            padding: 10px; text-align: center; font-size: 0.9em; color: #64b5f6;
        }
        .ai-status.thinking { background: rgba(255,243,205,0.2); border-color: #ffc107; color: #ffd54f; }
        .ai-status.hell-mode { 
            background: linear-gradient(45deg, #ff0000, #ff6600, #ff0000); 
            background-size: 200% 200%;
            animation: hell-glow 2s ease infinite;
            border-color: #ff0000; color: #fff; font-weight: bold;
        }
        @keyframes hell-glow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        .difficulty-selector { display: flex; gap: 10px; margin: 10px 0; flex-wrap: wrap; }
        .diff-btn { 
            flex: 1; min-width: 60px; padding: 10px; border: 2px solid #444; border-radius: 6px; 
            background: rgba(0,0,0,0.3); color: #ccc; cursor: pointer; text-align: center; font-size: 0.9em;
            transition: all 0.3s;
        }
        .diff-btn:hover { border-color: #666; color: #fff; }
        .diff-btn.selected { border-color: #ffd700; background: rgba(255,215,0,0.2); color: #ffd700; font-weight: bold; }
        .diff-btn.hell {
            border-color: #ff0000;
            background: linear-gradient(45deg, #330000, #660000);
            color: #ff6666;
            animation: hell-border 2s infinite;
        }
        .diff-btn.hell.selected {
            background: linear-gradient(45deg, #ff0000, #ff6600);
            color: #fff;
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
        }
        @keyframes hell-border {
            0%, 100% { border-color: #ff0000; }
            50% { border-color: #ff6600; }
        }
        .status-content { color: #ccc; line-height: 1.6; }
        .player-badge { display: inline-block; padding: 4px 12px; border-radius: 15px; font-size: 0.9em; font-weight: bold; margin-top: 5px; }
        .player-badge.red { background: #ffeb3b; color: #c62828; }
        .player-badge.black { background: #333; color: #fff; }
        .btn { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; transition: all 0.3s; font-family: inherit; }
        .btn-primary { background: #8b4513; color: white; }
        .btn-primary:hover { background: #6b3410; transform: translateY(-2px); }
        .btn-secondary { background: #444; color: #fff; }
        .btn-secondary:hover { background: #555; }
        .btn-danger { background: #c62828; color: white; }
        .btn-danger:hover { background: #a02020; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .moves-list { max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; font-size: 0.9em; color: #ccc; }
        .move-item { padding: 4px 0; border-bottom: 1px solid #444; display: flex; justify-content: space-between; }
        .move-number { color: #666; min-width: 30px; }
        .move-red { color: #ff6b6b; }
        .move-black { color: #888; }
        .settings-row { display: flex; align-items: center; justify-content: space-between; margin: 10px 0; }
        .toggle { position: relative; width: 50px; height: 26px; background: #444; border-radius: 13px; cursor: pointer; transition: background 0.3s; }
        .toggle.active { background: #4caf50; }
        .toggle-slider { position: absolute; top: 3px; left: 3px; width: 20px; height: 20px; background: white; border-radius: 50%; transition: transform 0.3s; }
        .toggle.active .toggle-slider { transform: translateX(24px); }
        .api-key-input { 
            width: 100%; padding: 8px; border: 1px solid #444; border-radius: 4px; 
            font-family: monospace; font-size: 0.8em; margin-top: 5px; background: rgba(0,0,0,0.3); color: #fff;
        }
        .api-status { font-size: 0.75em; margin-top: 5px; padding: 4px 8px; border-radius: 4px; display: inline-block; }
        .api-status.ok { background: rgba(76,175,80,0.2); color: #4caf50; }
        .api-status.error { background: rgba(244,67,54,0.2); color: #f44336; }
        .api-status.local { background: rgba(255,152,0,0.2); color: #ff9800; }
        .toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 12px 24px; border-radius: 25px; z-index: 1000; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        .toast.show { opacity: 1; }
        .toast.hell { background: linear-gradient(45deg, #ff0000, #ff6600); color: #fff; font-weight: bold; }
        @media (max-width: 800px) { .board { width: 360px; height: 400px; } .piece { width: 36px; height: 36px; font-size: 16px; } .side-panel { width: 100%; } }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ® ä¸­å›½è±¡æ£‹ ğŸ®</h1>
        <p class="subtitle">ä¸AIå¯¹æˆ˜ï¼ŒæŒ‘æˆ˜åœ°ç‹±æ¨¡å¼</p>
    </div>
    
    <div class="game-container">
        <div class="board-wrapper">
            <div class="board" id="board">
                <div class="board-lines">
                    <div class="horizontal-lines" id="hLines"></div>
                    <div class="vertical-lines" id="vLines"></div>
                    <div class="palace-lines">
                        <div class="palace-line top-left"></div>
                        <div class="palace-line top-right"></div>
                        <div class="palace-line bottom-left"></div>
                        <div class="palace-line bottom-right"></div>
                    </div>
                </div>
                <div class="river">æ¥š æ²³ æ±‰ ç•Œ</div>
                <div class="pieces-container" id="piecesContainer"></div>
            </div>
        </div>
        
        <div class="side-panel">
            <div class="panel-section">
                <div class="section-title">ğŸ¤– AI çŠ¶æ€</div>
                <div class="ai-status" id="aiStatus">
                    ç­‰å¾…å¼€å§‹...
                </div>
                <div id="apiStatusDisplay" style="margin-top: 10px; font-size: 0.85em;">
                    <span class="api-status local">æœ¬åœ°AIå°±ç»ª</span>
                </div>
                <div style="margin-top: 10px; font-size: 0.85em; color: #aaa;">
                    AI æ‰§é»‘æ£‹ï¼Œä½ æ‰§çº¢æ£‹å…ˆè¡Œ
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸšï¸ éš¾åº¦é€‰æ‹©</div>
                <div class="difficulty-selector">
                    <div class="diff-btn selected" onclick="setDifficulty('easy')">å…¥é—¨</div>
                    <div class="diff-btn" onclick="setDifficulty('medium')">ä¸­çº§</div>
                    <div class="diff-btn" onclick="setDifficulty('hard')">é«˜çº§</div>
                    <div class="diff-btn hell" onclick="setDifficulty('hell')">ğŸ”¥åœ°ç‹±</div>
                </div>
                <div id="hellModeInfo" style="display: none; margin-top: 10px; padding: 10px; background: rgba(255,0,0,0.1); border-radius: 6px; font-size: 0.8em; color: #ff9999;">
                    ğŸ”¥ åœ°ç‹±æ¨¡å¼ï¼šAIä½¿ç”¨äº‘ç«¯å¤§æ¨¡å‹+æœ¬åœ°è¶…å¼ºç®—æ³•ï¼Œå‡ ä¹ä¸å¯æˆ˜èƒœï¼
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸ”‘ API è®¾ç½®ï¼ˆåœ°ç‹±æ¨¡å¼æ¨èï¼‰</div>
                <div style="font-size: 0.8em; color: #aaa; margin-bottom: 8px;">
                    ä½¿ç”¨å›½å†…å…è´¹APIè·å¾—æ›´å¼ºAIä½“éªŒ<br>
                    ç•™ç©ºåˆ™ä½¿ç”¨æœ¬åœ°è¶…å¼ºAIï¼ˆåœ°ç‹±æ¨¡å¼ä¾ç„¶æå¼ºï¼‰
                </div>
                <select class="api-key-input" id="apiProvider" style="margin-bottom: 8px;">
                    <option value="zhipu">æ™ºè°±AI (GLM-4-Flash å…è´¹)</option>
                    <option value="deepseek">DeepSeek (V3/R1)</option>
                    <option value="moonshot">Kimi (Moonshot)</option>
                </select>
                <input type="password" class="api-key-input" id="apiKey" placeholder="è¾“å…¥ API Keyï¼ˆå¯é€‰ï¼‰">
                <div style="font-size: 0.75em; color: #888; margin-top: 5px;">
                    <a href="https://bigmodel.cn/usercenter/proj-mgmt/apikeys" target="_blank" style="color: #ffd700;">å…è´¹è·å–æ™ºè°±Key</a> | 
                    <a href="https://platform.deepseek.com/api_keys" target="_blank" style="color: #ffd700;">DeepSeek</a>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸ® æ¸¸æˆçŠ¶æ€</div>
                <div class="status-content">
                    <div>å½“å‰å›åˆ: <span id="currentTurn" style="font-weight:bold;color:#ff6b6b;">çº¢æ–¹ï¼ˆä½ ï¼‰</span></div>
                    <div>ä½ æ˜¯: <span class="player-badge red">çº¢æ–¹</span></div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸ›ï¸ æ“ä½œ</div>
                <button class="btn btn-primary" onclick="startGame()">ğŸ® å¼€å§‹æ–°æ¸¸æˆ</button>
                <button class="btn btn-secondary" onclick="undoMove()">â†©ï¸ æ‚”æ£‹</button>
                <button class="btn btn-danger" onclick="resign()">ğŸ³ï¸ è®¤è¾“</button>
            </div>
            
            <div class="panel-section">
                <div class="section-title">âš™ï¸ è®¾ç½®</div>
                <div class="settings-row">
                    <span>èµ°æ£‹éŸ³æ•ˆ</span>
                    <div class="toggle active" id="soundToggle" onclick="toggleSound()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <div class="settings-row">
                    <span>AI æç¤º</span>
                    <div class="toggle active" id="hintToggle" onclick="toggleHint()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸ“ èµ°æ£‹è®°å½•</div>
                <div class="moves-list" id="movesList">
                    <div style="color:#666;text-align:center;">æš‚æ— èµ°æ£‹è®°å½•</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>

    <script>
        // ==================== é…ç½® ====================
        const API_CONFIG = {
            zhipu: {
                url: 'https://open.bigmodel.cn/api/paas/v4/chat/completions',
                model: 'glm-4-flash',
                headers: (key) => ({
                    'Authorization': `Bearer ${key}`,
                    'Content-Type': 'application/json'
                })
            },
            deepseek: {
                url: 'https://api.deepseek.com/v1/chat/completions',
                model: 'deepseek-chat',
                headers: (key) => ({
                    'Authorization': `Bearer ${key}`,
                    'Content-Type': 'application/json'
                })
            },
            moonshot: {
                url: 'https://api.moonshot.cn/v1/chat/completions',
                model: 'moonshot-v1-8k',
                headers: (key) => ({
                    'Authorization': `Bearer ${key}`,
                    'Content-Type': 'application/json'
                })
            }
        };

        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        let gameState = {
            board: [],
            turn: 'red',
            lastMove: null,
            moveCount: 0,
            status: 'waiting',
            moves: [],
            difficulty: 'easy'
        };

        let selectedPiece = null;
        let soundEnabled = true;
        let hintEnabled = true;
        let isAIThinking = false;
        let moveHistory = [];
        let apiFailCount = 0;
        let lastApiError = null;

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const pieceNames = {
            'R': 'è½¦', 'N': 'é©¬', 'B': 'è±¡', 'A': 'å£«', 'K': 'å°†', 'C': 'ç‚®', 'P': 'å’',
            'r': 'è½¦', 'n': 'é©¬', 'b': 'ç›¸', 'a': 'ä»•', 'k': 'å¸…', 'c': 'ç‚®', 'p': 'å…µ'
        };
        
        const pieceValues = {
            'K': 10000, 'k': 10000,
            'R': 900, 'r': 900,
            'C': 450, 'c': 450,
            'N': 400, 'n': 400,
            'B': 200, 'b': 200,
            'A': 200, 'a': 200,
            'P': 100, 'p': 100
        };

        const positionBonus = {
            'P': [ // å’ï¼ˆé»‘æ–¹ï¼Œéœ€è¦ç¿»è½¬ï¼‰
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [20, 20, 20, 20, 20, 20, 20, 20, 20],
                [10, 10, 10, 10, 10, 10, 10, 10, 10],
                [5, 5, 5, 5, 5, 5, 5, 5, 5],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0]
            ],
            'N': [ // é©¬
                [0, -5, 0, 0, 0, 0, 0, -5, 0],
                [0, 0, 0, 5, 5, 5, 0, 0, 0],
                [0, 0, 10, 10, 10, 10, 10, 0, 0],
                [0, 5, 10, 15, 15, 15, 10, 5, 0],
                [5, 10, 15, 20, 20, 20, 15, 10, 5],
                [5, 10, 15, 20, 20, 20, 15, 10, 5],
                [0, 5, 10, 15, 15, 15, 10, 5, 0],
                [0, 0, 10, 10, 10, 10, 10, 0, 0],
                [0, 0, 0, 5, 5, 5, 0, 0, 0],
                [0, -5, 0, 0, 0, 0, 0, -5, 0]
            ],
            'R': [ // è½¦
                [0, 0, 10, 10, 10, 10, 10, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 10, 10, 10, 10, 10, 0, 0]
            ],
            'C': [ // ç‚®
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 5, 0, 0, 0, 0, 0, 5, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 5, 0, 0, 0, 0, 0, 5, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0]
            ]
        };

        // ==================== éŸ³æ•ˆ ====================
        function playSound(type) {
            if (!soundEnabled) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            switch(type) {
                case 'move': oscillator.frequency.value = 400; gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.1); break;
                case 'capture': oscillator.frequency.value = 200; gainNode.gain.setValueAtTime(0.5, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.2); break;
                case 'check': oscillator.frequency.value = 800; gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.3); break;
                case 'win': oscillator.frequency.value = 600; gainNode.gain.setValueAtTime(0.4, audioContext.currentTime); oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.5); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.5); break;
                case 'select': oscillator.frequency.value = 600; gainNode.gain.setValueAtTime(0.2, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.05); break;
                case 'hell': 
                    // åœ°ç‹±æ¨¡å¼éŸ³æ•ˆ
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.value = 100; 
                    gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime); 
                    oscillator.stop(audioContext.currentTime + 0.5); 
                    break;
            }
        }
        
        function toggleSound() { soundEnabled = !soundEnabled; document.getElementById('soundToggle').classList.toggle('active'); showToast(soundEnabled ? 'éŸ³æ•ˆå·²å¼€å¯' : 'éŸ³æ•ˆå·²å…³é—­'); }
        function toggleHint() { hintEnabled = !hintEnabled; document.getElementById('hintToggle').classList.toggle('active'); showToast(hintEnabled ? 'AIæç¤ºå·²å¼€å¯' : 'AIæç¤ºå·²å…³é—­'); }
        
        function setDifficulty(level) {
            gameState.difficulty = level;
            document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
            
            const hellInfo = document.getElementById('hellModeInfo');
            if (level === 'hell') {
                hellInfo.style.display = 'block';
                playSound('hell');
                showToast('ğŸ”¥ åœ°ç‹±æ¨¡å¼å·²å¼€å¯ï¼AIå°†å…¨åŠ›ä»¥èµ´ï¼', true);
            } else {
                hellInfo.style.display = 'none';
                showToast(`éš¾åº¦è®¾ç½®ä¸º: ${level === 'easy' ? 'å…¥é—¨' : level === 'medium' ? 'ä¸­çº§' : 'é«˜çº§'}`);
            }
        }
        
        // ==================== åˆå§‹åŒ– ====================
        function init() {
            drawBoard();
            initBoard();
        }
        
        function drawBoard() {
            const hLines = document.getElementById('hLines'), vLines = document.getElementById('vLines');
            for (let i = 0; i < 10; i++) { const line = document.createElement('div'); line.className = 'horizontal-line'; line.style.top = `${i * 50 + 25}px`; hLines.appendChild(line); }
            for (let i = 0; i < 9; i++) {
                if (i === 0 || i === 8) { const line = document.createElement('div'); line.className = 'vertical-line'; line.style.left = `${i * 50 + 25}px`; line.style.top = '25px'; line.style.height = '450px'; vLines.appendChild(line); }
                else {
                    const line1 = document.createElement('div'); line1.className = 'vertical-line'; line1.style.left = `${i * 50 + 25}px`; line1.style.top = '25px'; line1.style.height = '200px'; vLines.appendChild(line1);
                    const line2 = document.createElement('div'); line2.className = 'vertical-line'; line2.style.left = `${i * 50 + 25}px`; line2.style.top = '275px'; line2.style.height = '200px'; vLines.appendChild(line2);
                }
            }
        }
        
        function initBoard() {
            gameState.board = [['R','N','B','A','K','A','B','N','R'],['.','.','.','.','.','.','.','.','.'],['.','C','.','.','.','.','.','C','.'],['P','.','P','.','P','.','P','.','P'],['.','.','.','.','.','.','.','.','.'],['.','.','.','.','.','.','.','.','.'],['p','.','p','.','p','.','p','.','p'],['.','c','.','.','.','.','.','c','.'],['.','.','.','.','.','.','.','.','.'],['r','n','b','a','k','a','b','n','r']];
            gameState.turn = 'red';
            gameState.lastMove = null;
            gameState.moveCount = 0;
            gameState.moves = [];
            gameState.status = 'playing';
            moveHistory = [];
            selectedPiece = null;
            isAIThinking = false;
            apiFailCount = 0;
            lastApiError = null;
            updateAIStatus('ç­‰å¾…å¼€å§‹...');
            updateApiStatus('local');
            renderPieces();
            updateUI();
            showToast('æ¸¸æˆå¼€å§‹ï¼çº¢æ–¹å…ˆè¡Œ');
        }
        
        function startGame() {
            initBoard();
        }
        
        // ==================== æ£‹å­æ“ä½œ ====================
        function renderPieces() {
            const container = document.getElementById('piecesContainer');
            container.innerHTML = '';
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece !== '.') {
                        const el = document.createElement('div');
                        el.className = `piece ${piece === piece.toUpperCase() ? 'black' : 'red'}`;
                        if (isAIThinking && piece === piece.toUpperCase()) el.classList.add('ai-thinking');
                        el.textContent = pieceNames[piece];
                        el.style.left = `${col * 50 + 3}px`;
                        el.style.top = `${row * 50 + 3}px`;
                        if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) el.classList.add('selected');
                        if (gameState.lastMove) {
                            const from = gameState.lastMove.from, to = gameState.lastMove.to;
                            if ((row === from.row && col === from.col) || (row === to.row && col === to.col)) el.classList.add('last-move');
                        }
                        if (piece.toUpperCase() === 'K' && isInCheck(piece === piece.toLowerCase())) el.classList.add('check');
                        el.onclick = () => onPieceClick(row, col);
                        container.appendChild(el);
                    }
                }
            }
            if (selectedPiece && !isAIThinking) showMoveHints(selectedPiece.row, selectedPiece.col);
        }
        
        function showMoveHints(row, col) {
            const container = document.getElementById('piecesContainer');
            container.querySelectorAll('.move-hint').forEach(h => h.remove());
            const piece = gameState.board[row][col];
            if (!piece || piece === '.') return;
            const isRed = piece === piece.toLowerCase();
            if (!isRed) return;
            if (gameState.turn !== 'red') return;
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const hint = document.createElement('div');
                        hint.className = 'move-hint';
                        hint.style.left = `${c * 50 + 25}px`;
                        hint.style.top = `${r * 50 + 25}px`;
                        hint.onclick = (e) => { e.stopPropagation(); onHintClick(r, c); };
                        container.appendChild(hint);
                    }
                }
            }
        }
        
        function onPieceClick(row, col) {
            if (isAIThinking) { showToast('AIæ€è€ƒä¸­ï¼Œè¯·ç¨å€™...'); return; }
            if (gameState.status !== 'playing') { showToast('æ¸¸æˆå·²ç»“æŸï¼'); return; }
            if (gameState.turn !== 'red') { showToast('è¿˜æ²¡è½®åˆ°ä½ ï¼'); return; }
            
            const piece = gameState.board[row][col];
            if (!piece || piece === '.') return;
            
            const isRed = piece === piece.toLowerCase();
            
            if (selectedPiece) {
                if (isValidMove(selectedPiece.row, selectedPiece.col, row, col)) {
                    makeMove(selectedPiece.row, selectedPiece.col, row, col);
                    selectedPiece = null;
                    return;
                }
            }
            
            if (!isRed) {
                showToast('è¿™æ˜¯AIçš„æ£‹å­');
                return;
            }
            
            playSound('select');
            if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) selectedPiece = null;
            else selectedPiece = { row, col, piece };
            renderPieces();
        }
        
        function onHintClick(row, col) {
            if (!selectedPiece || isAIThinking) return;
            makeMove(selectedPiece.row, selectedPiece.col, row, col);
            selectedPiece = null;
        }
        
        // ==================== èµ°æ£‹é€»è¾‘ ====================
        function isValidMove(fromRow, fromCol, toRow, toCol, board = gameState.board) {
            if (toRow < 0 || toRow > 9 || toCol < 0 || toCol > 8) return false;
            if (fromRow === toRow && fromCol === toCol) return false;
            const piece = board[fromRow][fromCol], target = board[toRow][toCol];
            if (target !== '.' && target !== '') { const isRedPiece = piece === piece.toLowerCase(), isRedTarget = target === target.toLowerCase(); if (isRedPiece === isRedTarget) return false; }
            const type = piece.toUpperCase(), isRed = piece === piece.toLowerCase();
            switch(type) {
                case 'R': return validateRook(fromRow, fromCol, toRow, toCol, board);
                case 'N': return validateKnight(fromRow, fromCol, toRow, toCol, board);
                case 'B': return validateBishop(fromRow, fromCol, toRow, toCol, isRed, board);
                case 'A': return validateAdvisor(fromRow, fromCol, toRow, toCol, isRed, board);
                case 'K': return validateKing(fromRow, fromCol, toRow, toCol, isRed, board);
                case 'C': return validateCannon(fromRow, fromCol, toRow, toCol, board);
                case 'P': return validatePawn(fromRow, fromCol, toRow, toCol, isRed, board);
                default: return false;
            }
        }
        
        function countPiecesBetween(r1, c1, r2, c2, board) {
            let count = 0;
            if (r1 === r2) { const min = Math.min(c1, c2), max = Math.max(c1, c2); for (let c = min + 1; c < max; c++) if (board[r1][c] !== '.' && board[r1][c] !== '') count++; }
            else if (c1 === c2) { const min = Math.min(r1, r2), max = Math.max(r1, r2); for (let r = min + 1; r < max; r++) if (board[r][c1] !== '.' && board[r][c1] !== '') count++; }
            return count;
        }
        
        function validateRook(r1, c1, r2, c2, board) { if (r1 !== r2 && c1 !== c2) return false; return countPiecesBetween(r1, c1, r2, c2, board) === 0; }
        function validateKnight(r1, c1, r2, c2, board) {
            const dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1); if (!((dr === 2 && dc === 1) || (dr === 1 && dc === 2))) return false;
            if (dr === 2) { const blockR = r1 + (r2 > r1 ? 1 : -1); if (board[blockR][c1] !== '.' && board[blockR][c1] !== '') return false; }
            else { const blockC = c1 + (c2 > c1 ? 1 : -1); if (board[r1][blockC] !== '.' && board[r1][blockC] !== '') return false; }
            return true;
        }
        function validateBishop(r1, c1, r2, c2, isRed, board) {
            const dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1); if (dr !== 2 || dc !== 2) return false;
            if (isRed && r2 < 5) return false; if (!isRed && r2 > 4) return false;
            const eyeR = (r1 + r2) / 2, eyeC = (c1 + c2) / 2; if (board[eyeR][eyeC] !== '.' && board[eyeR][eyeC] !== '') return false;
            return true;
        }
        function validateAdvisor(r1, c1, r2, c2, isRed, board) {
            const dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1); if (dr !== 1 || dc !== 1) return false;
            if (c2 < 3 || c2 > 5) return false; if (isRed && r2 < 7) return false; if (!isRed && r2 > 2) return false;
            return true;
        }
        function validateKing(r1, c1, r2, c2, isRed, board) {
            const dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1);
            if (c1 === c2) { let hasPiece = false; const min = Math.min(r1, r2), max = Math.max(r1, r2); for (let r = min + 1; r < max; r++) if (board[r][c1] !== '.' && board[r][c1] !== '') { hasPiece = true; break; } if (!hasPiece) { const target = board[r2][c2]; if (target && (target.toUpperCase() === 'K')) return true; } }
            if (dr + dc !== 1) return false; if (c2 < 3 || c2 > 5) return false; if (isRed && r2 < 7) return false; if (!isRed && r2 > 2) return false;
            return true;
        }
        function validateCannon(r1, c1, r2, c2, board) {
            if (r1 !== r2 && c1 !== c2) return false;
            const count = countPiecesBetween(r1, c1, r2, c2, board), target = board[r2][c2];
            if (target === '.' || target === '') return count === 0;
            else return count === 1;
        }
        function validatePawn(r1, c1, r2, c2, isRed, board) {
            const dr = r2 - r1, dc = Math.abs(c2 - c1);
            if (isRed) { if (dr > 0) return false; if (r1 >= 5 && dc !== 0) return false; if (dr === -1 && dc === 0) return true; if (r1 < 5 && dr === 0 && dc === 1) return true; }
            else { if (dr < 0) return false; if (r1 <= 4 && dc !== 0) return false; if (dr === 1 && dc === 0) return true; if (r1 > 4 && dr === 0 && dc === 1) return true; }
            return false;
        }
        
        function isInCheck(isRed, board = gameState.board) {
            let kingRow, kingCol; const kingChar = isRed ? 'k' : 'K';
            for (let r = 0; r < 10; r++) for (let c = 0; c < 9; c++) if (board[r][c] === kingChar) { kingRow = r; kingCol = c; break; }
            if (kingRow === undefined) return false;
            for (let r = 0; r < 10; r++) for (let c = 0; c < 9; c++) { const piece = board[r][c]; if (piece !== '.' && piece !== '') { const pieceIsRed = piece === piece.toLowerCase(); if (pieceIsRed !== isRed) if (isValidMove(r, c, kingRow, kingCol, board)) return true; } }
            return false;
        }
        
        // ==================== æ¸¸æˆæ“ä½œ ====================
        async function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol], target = gameState.board[toRow][toCol], isCapture = target !== '.' && target !== '';
            
            moveHistory.push(JSON.parse(JSON.stringify(gameState.board)));
            
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = '.';
            gameState.moves.push(`${pieceNames[piece]} ${String.fromCharCode(97 + fromCol)}${9-fromRow}â†’${String.fromCharCode(97 + toCol)}${9-toRow}`);
            gameState.lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };
            gameState.moveCount++;
            
            isCapture ? playSound('capture') : playSound('move');
            
            const opponentIsRed = piece === piece.toLowerCase();
            if (isInCheck(!opponentIsRed)) { playSound('check'); showToast('å°†å†›ï¼'); }
            
            if (target && target.toUpperCase() === 'K') {
                const winner = opponentIsRed ? 'é»‘æ–¹' : 'çº¢æ–¹';
                showToast(`ğŸ‰ ${winner}è·èƒœï¼`, gameState.difficulty === 'hell');
                gameState.status = 'finished';
                playSound('win');
                updateAIStatus('æ¸¸æˆç»“æŸ');
                renderPieces();
                updateUI();
                return;
            }
            
            gameState.turn = gameState.turn === 'red' ? 'black' : 'red';
            updateUI();
            renderPieces();
            
            if (gameState.turn === 'black' && gameState.status === 'playing') {
                setTimeout(() => aiMove(), 500);
            }
        }
        
        function updateUI() {
            const turnText = document.getElementById('currentTurn');
            if (gameState.turn === 'red') {
                turnText.textContent = 'çº¢æ–¹ï¼ˆä½ ï¼‰';
                turnText.style.color = '#ff6b6b';
            } else {
                turnText.textContent = 'é»‘æ–¹ï¼ˆAIï¼‰';
                turnText.style.color = '#888';
            }
            
            const movesList = document.getElementById('movesList');
            if (gameState.moves.length === 0) movesList.innerHTML = '<div style="color:#666;text-align:center;">æš‚æ— èµ°æ£‹è®°å½•</div>';
            else {
                movesList.innerHTML = gameState.moves.map((m, i) => {
                    const isRed = i % 2 === 0;
                    return `<div class="move-item"><span class="move-number">${Math.floor(i/2)+1}.</span><span class="${isRed ? 'move-red' : 'move-black'}">${m}</span></div>`;
                }).join('');
                movesList.scrollTop = movesList.scrollHeight;
            }
        }
        
        function updateAIStatus(text, isHell = false) {
            const status = document.getElementById('aiStatus');
            status.textContent = text;
            status.className = 'ai-status' + (isHell ? ' hell-mode' : (text.includes('æ€è€ƒ') ? ' thinking' : ''));
        }

        function updateApiStatus(status, message = '') {
            const display = document.getElementById('apiStatusDisplay');
            const statusClass = status === 'ok' ? 'ok' : (status === 'error' ? 'error' : 'local');
            const statusText = status === 'ok' ? 'äº‘ç«¯AIå·²è¿æ¥' : (status === 'error' ? `APIå¤±è´¥(${message})` : 'æœ¬åœ°AIè¿è¡Œä¸­');
            display.innerHTML = `<span class="api-status ${statusClass}">${statusText}</span>`;
        }
        
        // ==================== AI èµ°æ£‹ ====================
        async function aiMove() {
            if (gameState.status !== 'playing') return;
            
            isAIThinking = true;
            const isHell = gameState.difficulty === 'hell';
            updateAIStatus(isHell ? 'ğŸ”¥ åœ°ç‹±AIæ­£åœ¨è®¡ç®—æ€æ‹›...' : 'AI æ€è€ƒä¸­...', isHell);
            renderPieces();
            
            try {
                let move;
                const apiKey = document.getElementById('apiKey').value.trim();
                const provider = document.getElementById('apiProvider').value;
                
                // åœ°ç‹±æ¨¡å¼ä¼˜å…ˆå°è¯•API
                if (isHell && apiKey && apiFailCount < 3) {
                    try {
                        move = await getAIMoveFromAPI(apiKey, provider);
                        updateApiStatus('ok');
                    } catch (err) {
                        apiFailCount++;
                        lastApiError = err.message;
                        updateApiStatus('error', 'åˆ‡æ¢åˆ°æœ¬åœ°');
                        console.warn('API failed, falling back to local AI:', err);
                        move = getLocalAIMove();
                    }
                } else {
                    if (isHell && !apiKey) {
                        updateApiStatus('local', 'åœ°ç‹±æœ¬åœ°');
                    }
                    move = getLocalAIMove();
                }
                
                if (move) {
                    const { from, to } = move;
                    makeMove(from.row, from.col, to.row, to.col);
                    updateAIStatus(isHell ? 'ğŸ”¥ åœ°ç‹±AIç­‰å¾…ä½ å—æ­»...' : 'ç­‰å¾…ä½ èµ°æ£‹...', isHell);
                } else {
                    showToast('AI è®¤è¾“ï¼ä½ èµ¢äº†ï¼', isHell);
                    gameState.status = 'finished';
                    playSound('win');
                    updateAIStatus('AI è®¤è¾“');
                }
            } catch (err) {
                console.error('AI error:', err);
                const move = getLocalAIMove();
                if (move) {
                    const { from, to } = move;
                    makeMove(from.row, from.col, to.row, to.col);
                    updateAIStatus('ç­‰å¾…ä½ èµ°æ£‹...');
                }
            } finally {
                isAIThinking = false;
                renderPieces();
            }
        }
        
        // ==================== æœ¬åœ°AIï¼ˆåœ°ç‹±æ¨¡å¼å¢å¼ºç‰ˆï¼‰ ====================
        function getLocalAIMove() {
            const isHell = gameState.difficulty === 'hell';
            const depth = isHell ? 4 : (gameState.difficulty === 'hard' ? 3 : (gameState.difficulty === 'medium' ? 2 : 1));
            
            // ä½¿ç”¨Alpha-Betaå‰ªæ
            const result = alphaBetaSearch(depth, -Infinity, Infinity, true);
            
            if (result.move) {
                return result.move;
            }
            
            // å›é€€ï¼šéšæœºé€‰æ‹©åˆæ³•èµ°æ³•
            const validMoves = getAllValidMoves(true);
            if (validMoves.length === 0) return null;
            return validMoves[Math.floor(Math.random() * validMoves.length)];
        }

        function alphaBetaSearch(depth, alpha, beta, isMaximizing) {
            if (depth === 0) {
                return { score: evaluateBoard(), move: null };
            }

            const moves = getAllValidMoves(isMaximizing);
            
            // å°†å†›æ£€æµ‹ä¼˜å…ˆ
            const checkMoves = moves.filter(m => {
                const testBoard = simulateMove(m.from.row, m.from.col, m.to.row, m.to.col);
                return isInCheck(true, testBoard); // æ£€æµ‹æ˜¯å¦å°†å†›çº¢æ–¹
            });

            // æ’åºï¼šåƒå­ã€å°†å†›ã€æ™®é€š
            moves.sort((a, b) => {
                const scoreA = getMovePriority(a);
                const scoreB = getMovePriority(b);
                return scoreB - scoreA;
            });

            let bestMove = null;

            if (isMaximizing) { // AI (é»‘æ–¹) æœ€å¤§åŒ–
                let maxEval = -Infinity;
                for (const move of moves) {
                    const testBoard = simulateMove(move.from.row, move.from.col, move.to.row, move.to.col);
                    const evalScore = alphaBetaSearch(depth - 1, alpha, beta, false, testBoard).score;
                    
                    if (evalScore > maxEval) {
                        maxEval = evalScore;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, evalScore);
                    if (beta <= alpha) break;
                }
                return { score: maxEval, move: bestMove };
            } else { // æœ€å°åŒ–ï¼ˆå‡è®¾å¯¹æ‰‹æœ€ä½³ï¼‰
                let minEval = Infinity;
                for (const move of getAllValidMoves(false)) {
                    const testBoard = simulateMove(move.from.row, move.from.col, move.to.row, move.to.col);
                    const evalScore = alphaBetaSearch(depth - 1, alpha, beta, true, testBoard).score;
                    
                    minEval = Math.min(minEval, evalScore);
                    beta = Math.min(beta, evalScore);
                    if (beta <= alpha) break;
                }
                return { score: minEval, move: null };
            }
        }

        function getMovePriority(move) {
            const piece = gameState.board[move.from.row][move.from.col];
            const target = gameState.board[move.to.row][move.to.col];
            let score = 0;
            
            if (target !== '.') {
                score += pieceValues[target] * 10; // åƒå­åŠ åˆ†
            }
            
            // ä½ç½®åŠ åˆ†
            const type = piece.toUpperCase();
            if (positionBonus[type]) {
                const bonus = positionBonus[type][move.to.row][move.to.col];
                score += bonus;
            }
            
            return score;
        }

        function getAllValidMoves(forBlack) {
            const moves = [];
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    const piece = gameState.board[r][c];
                    if (piece !== '.' && piece !== '') {
                        const isBlackPiece = piece === piece.toUpperCase();
                        if (isBlackPiece === forBlack) {
                            for (let tr = 0; tr < 10; tr++) {
                                for (let tc = 0; tc < 9; tc++) {
                                    if (isValidMove(r, c, tr, tc)) {
                                        moves.push({
                                            from: { row: r, col: c },
                                            to: { row: tr, col: tc },
                                            piece: piece,
                                            target: gameState.board[tr][tc]
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return moves;
        }

        function simulateMove(fromRow, fromCol, toRow, toCol, board = gameState.board) {
            const newBoard = JSON.parse(JSON.stringify(board));
            newBoard[toRow][toCol] = newBoard[fromRow][fromCol];
            newBoard[fromRow][fromCol] = '.';
            return newBoard;
        }

        function evaluateBoard() {
            let score = 0;
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    const piece = gameState.board[r][c];
                    if (piece !== '.' && piece !== '') {
                        const value = pieceValues[piece] || 0;
                        const isBlack = piece === piece.toUpperCase();
                        
                        // åŸºç¡€å­åŠ›ä»·å€¼
                        if (isBlack) score += value;
                        else score -= value;
                        
                        // ä½ç½®åŠ åˆ†
                        const type = piece.toUpperCase();
                        if (positionBonus[type]) {
                            const bonus = positionBonus[type][r][c];
                            if (isBlack) score += bonus;
                            else score -= bonus;
                        }
                        
                        // çµæ´»æ€§åŠ åˆ†
                        let mobility = 0;
                        for (let tr = 0; tr < 10; tr++) {
                            for (let tc = 0; tc < 9; tc++) {
                                if (isValidMove(r, c, tr, tc, gameState.board)) {
                                    mobility++;
                                }
                            }
                        }
                        if (isBlack) score += mobility * 10;
                        else score -= mobility * 10;
                    }
                }
            }
            
            // å°†å†›é¢å¤–åŠ åˆ†
            if (isInCheck(true)) score += 500; // çº¢æ–¹è¢«å°†å†›ï¼Œé»‘æ–¹åŠ åˆ†
            if (isInCheck(false)) score -= 500; // é»‘æ–¹è¢«å°†å†›ï¼Œé»‘æ–¹å‡åˆ†
            
            return score;
        }
        
        // ==================== API AI ====================
        async function getAIMoveFromAPI(apiKey, provider) {
            const boardStr = gameState.board.map((row, r) => 
                row.map((p, c) => {
                    if (p === '.') return ' . ';
                    return ` ${p} `;
                }).join('')
            ).join('\n');
            
            const prompt = `ä½ æ˜¯ä¸­å›½è±¡æ£‹ç‰¹çº§å¤§å¸ˆï¼Œæ‰§é»‘æ£‹ï¼ˆå¤§å†™å­—æ¯ï¼‰ã€‚å½“å‰å±€é¢ï¼š

${boardStr}

æ£‹ç›˜åæ ‡ï¼šè¡Œ0-9ï¼ˆä»ä¸Šåˆ°ä¸‹ï¼‰ï¼Œåˆ—0-8ï¼ˆä»å·¦åˆ°å³ï¼‰ã€‚
ä½ æ˜¯é»‘æ–¹ï¼ˆå¤§å†™ï¼‰ï¼Œè¦èµ¢æ£‹ã€‚

è¯·ç»™å‡ºæœ€ä½³èµ°æ³•ï¼Œåªå›å¤æ ¼å¼ï¼šfromRow,fromCol,toRow,toCol
ä¾‹å¦‚ï¼š3,0,4,0`;

            const config = API_CONFIG[provider];
            
            const response = await fetch(config.url, {
                method: 'POST',
                headers: config.headers(apiKey),
                body: JSON.stringify({
                    model: config.model,
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.1,
                    max_tokens: 50
                })
            });
            
            if (!response.ok) {
                const error = await response.text();
                throw new Error(`API error: ${response.status} - ${error}`);
            }
            
            const data = await response.json();
            const text = data.choices[0].message.content;
            const match = text.match(/(\d+)[,\s]+(\d+)[,\s]+(\d+)[,\s]+(\d+)/);
            
            if (match) {
                const [_, fr, fc, tr, tc] = match.map(Number);
                if (isValidMove(fr, fc, tr, tc)) {
                    return { from: { row: fr, col: fc }, to: { row: tr, col: tc } };
                }
            }
            
            throw new Error('Invalid move format from API');
        }
        
        // ==================== å…¶ä»–åŠŸèƒ½ ====================
        function undoMove() {
            if (isAIThinking) { showToast('AIæ€è€ƒä¸­ï¼Œæ— æ³•æ‚”æ£‹'); return; }
            if (moveHistory.length < 2) { showToast('æ— æ³•æ‚”æ£‹'); return; }
            
            moveHistory.pop();
            gameState.board = moveHistory.pop();
            
            gameState.turn = 'red';
            gameState.moves = gameState.moves.slice(0, -2);
            gameState.moveCount -= 2;
            gameState.lastMove = null;
            
            renderPieces();
            updateUI();
            showToast('å·²æ‚”æ£‹');
        }
        
        function resign() {
            if (gameState.status !== 'playing') return;
            if (!confirm('ç¡®å®šè¦è®¤è¾“å—ï¼Ÿ')) return;
            const isHell = gameState.difficulty === 'hell';
            showToast(isHell ? 'ğŸ”¥ åœ°ç‹±AIè·èƒœï¼äººç±»æ— æ³•æŠµæŒ¡ï¼' : 'ä½ è®¤è¾“äº†ï¼ŒAIè·èƒœï¼', isHell);
            gameState.status = 'finished';
            playSound('win');
            updateAIStatus(isHell ? 'ğŸ”¥ åœ°ç‹±AIç»Ÿæ²»æˆ˜åœº' : 'AI è·èƒœ', isHell);
        }
        
        function showToast(msg, isHell = false) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.className = 'toast' + (isHell ? ' hell' : '');
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }
        
        window.onload = init;
    </script>
</body>
</html>
