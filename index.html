<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸­å›½è±¡æ£‹ - AIå¯¹æˆ˜</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: "Microsoft YaHei", "SimSun", sans-serif;
            background: linear-gradient(135deg, #f5f5dc 0%, #e8dcc0 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .header { text-align: center; margin-bottom: 20px; }
        h1 { color: #8b4513; font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.1); margin-bottom: 10px; }
        .subtitle { color: #666; font-size: 1.1em; }
        .game-container {
            display: flex; gap: 30px; align-items: flex-start; flex-wrap: wrap;
            justify-content: center; max-width: 1200px; width: 100%;
        }
        .board-wrapper {
            position: relative; background: #f0d9b5; padding: 40px;
            border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 3px solid #8b4513;
        }
        .board { width: 450px; height: 500px; position: relative; background: #f0d9b5; }
        .board-lines { position: absolute; width: 100%; height: 100%; }
        .horizontal-lines, .vertical-lines { position: absolute; width: 100%; height: 100%; }
        .horizontal-line { position: absolute; width: 400px; height: 1px; background: #333; left: 25px; }
        .vertical-line { position: absolute; width: 1px; background: #333; }
        .palace-lines { position: absolute; width: 100%; height: 100%; pointer-events: none; }
        .palace-line { position: absolute; width: 141px; height: 1px; background: #333; transform-origin: left center; }
        .palace-line.top-left { top: 75px; left: 154px; transform: rotate(45deg); }
        .palace-line.top-right { top: 75px; right: 154px; transform: rotate(-45deg); }
        .palace-line.bottom-left { bottom: 75px; left: 154px; transform: rotate(-45deg); }
        .palace-line.bottom-right { bottom: 75px; right: 154px; transform: rotate(45deg); }
        .river {
            position: absolute; top: 225px; left: 0; width: 100%; height: 50px;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; color: #8b4513; font-weight: bold; letter-spacing: 20px;
        }
        .pieces-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .piece {
            position: absolute; width: 44px; height: 44px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; font-weight: bold; cursor: pointer;
            transition: all 0.3s ease; user-select: none; z-index: 10;
        }
        .piece.red {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #cc0000);
            color: #ffeb3b; border: 2px solid #8b0000; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .piece.black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            color: #fff; border: 2px solid #333; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .piece:hover { transform: scale(1.1); box-shadow: 0 0 15px rgba(255,215,0,0.8); }
        .piece.selected { box-shadow: 0 0 20px #ffd700, 0 0 40px #ffd700; animation: pulse 1s infinite; }
        .piece.ai-thinking { animation: ai-pulse 1s infinite; box-shadow: 0 0 20px #00ff00; }
        @keyframes pulse { 0%, 100% { transform: scale(1.1); } 50% { transform: scale(1.2); } }
        @keyframes ai-pulse { 0%, 100% { box-shadow: 0 0 20px #00ff00; } 50% { box-shadow: 0 0 40px #00ff00, 0 0 60px #00ff00; } }
        .piece.last-move { border: 3px solid #00ff00; }
        .piece.check { animation: check-pulse 0.5s infinite; box-shadow: 0 0 20px #ff0000; }
        @keyframes check-pulse { 0%, 100% { box-shadow: 0 0 20px #ff0000; } 50% { box-shadow: 0 0 40px #ff0000, 0 0 60px #ff0000; } }
        .move-hint {
            position: absolute; width: 16px; height: 16px; background: rgba(0,255,0,0.6);
            border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: auto; cursor: pointer; z-index: 5;
        }
        .move-hint:hover { background: rgba(0,255,0,0.9); transform: translate(-50%, -50%) scale(1.3); }
        .side-panel { display: flex; flex-direction: column; gap: 20px; width: 320px; }
        .panel-section {
            background: white; padding: 20px; border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1); border: 2px solid #8b4513;
        }
        .section-title { font-weight: bold; color: #8b4513; margin-bottom: 15px; font-size: 1.1em; display: flex; align-items: center; gap: 8px; }
        .ai-status { 
            background: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; 
            padding: 10px; text-align: center; font-size: 0.9em; color: #1976d2;
        }
        .ai-status.thinking { background: #fff3cd; border-color: #ffc107; color: #856404; }
        .difficulty-selector { display: flex; gap: 10px; margin: 10px 0; }
        .diff-btn { 
            flex: 1; padding: 10px; border: 2px solid #ddd; border-radius: 6px; 
            background: white; cursor: pointer; text-align: center; font-size: 0.9em;
        }
        .diff-btn:hover { border-color: #8b4513; }
        .diff-btn.selected { border-color: #8b4513; background: #e8dcc0; font-weight: bold; }
        .status-content { color: #333; line-height: 1.6; }
        .player-badge { display: inline-block; padding: 4px 12px; border-radius: 15px; font-size: 0.9em; font-weight: bold; margin-top: 5px; }
        .player-badge.red { background: #ffeb3b; color: #c62828; }
        .player-badge.black { background: #333; color: #fff; }
        .btn { width: 100%; padding: 12px; margin: 8px 0; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; transition: all 0.3s; font-family: inherit; }
        .btn-primary { background: #8b4513; color: white; }
        .btn-primary:hover { background: #6b3410; transform: translateY(-2px); }
        .btn-secondary { background: #e0e0e0; color: #333; }
        .btn-secondary:hover { background: #d0d0d0; }
        .btn-danger { background: #c62828; color: white; }
        .btn-danger:hover { background: #a02020; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .moves-list { max-height: 200px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 6px; font-size: 0.9em; }
        .move-item { padding: 4px 0; border-bottom: 1px solid #eee; color: #555; display: flex; justify-content: space-between; }
        .move-number { color: #999; min-width: 30px; }
        .move-red { color: #c62828; }
        .move-black { color: #333; }
        .settings-row { display: flex; align-items: center; justify-content: space-between; margin: 10px 0; }
        .toggle { position: relative; width: 50px; height: 26px; background: #ccc; border-radius: 13px; cursor: pointer; transition: background 0.3s; }
        .toggle.active { background: #4caf50; }
        .toggle-slider { position: absolute; top: 3px; left: 3px; width: 20px; height: 20px; background: white; border-radius: 50%; transition: transform 0.3s; }
        .toggle.active .toggle-slider { transform: translateX(24px); }
        .toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 12px 24px; border-radius: 25px; z-index: 1000; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        .toast.show { opacity: 1; }
        .api-key-input { 
            width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; 
            font-family: monospace; font-size: 0.8em; margin-top: 5px;
        }
        @media (max-width: 800px) { .board { width: 360px; height: 400px; } .piece { width: 36px; height: 36px; font-size: 16px; } .side-panel { width: 100%; } }
    </style>
<base target="_blank">
</head>
<body>
    <div class="header">
        <h1>ğŸ® ä¸­å›½è±¡æ£‹ ğŸ®</h1>
        <p class="subtitle">ä¸AIå¯¹æˆ˜ï¼Œæå‡æ£‹è‰º</p>
    </div>
    
    <div class="game-container">
        <div class="board-wrapper">
            <div class="board" id="board">
                <div class="board-lines">
                    <div class="horizontal-lines" id="hLines"></div>
                    <div class="vertical-lines" id="vLines"></div>
                    <div class="palace-lines">
                        <div class="palace-line top-left"></div>
                        <div class="palace-line top-right"></div>
                        <div class="palace-line bottom-left"></div>
                        <div class="palace-line bottom-right"></div>
                    </div>
                </div>
                <div class="river">æ¥š æ²³ æ±‰ ç•Œ</div>
                <div class="pieces-container" id="piecesContainer"></div>
            </div>
        </div>
        
        <div class="side-panel">
            <div class="panel-section">
                <div class="section-title">ğŸ¤– AI çŠ¶æ€</div>
                <div class="ai-status" id="aiStatus">
                    ç­‰å¾…å¼€å§‹...
                </div>
                <div style="margin-top: 10px; font-size: 0.85em; color: #666;">
                    AI æ‰§é»‘æ£‹ï¼Œä½ æ‰§çº¢æ£‹å…ˆè¡Œ
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸšï¸ éš¾åº¦é€‰æ‹©</div>
                <div class="difficulty-selector">
                    <div class="diff-btn selected" onclick="setDifficulty('easy')">å…¥é—¨</div>
                    <div class="diff-btn" onclick="setDifficulty('medium')">ä¸­çº§</div>
                    <div class="diff-btn" onclick="setDifficulty('hard')">é«˜çº§</div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸ”‘ API è®¾ç½®ï¼ˆå¯é€‰ï¼‰</div>
                <div style="font-size: 0.8em; color: #666; margin-bottom: 8px;">
                    ä½¿ç”¨è‡ªå·±çš„ API Key è·å¾—æ›´å¥½ä½“éªŒ<br>
                    ç•™ç©ºä½¿ç”¨é»˜è®¤ï¼ˆå¯èƒ½é™é€Ÿï¼‰
                </div>
                <input type="password" class="api-key-input" id="apiKey" placeholder="è¾“å…¥ Gemini API Keyï¼ˆå¯é€‰ï¼‰">
                <div style="font-size: 0.75em; color: #999; margin-top: 5px;">
                    <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: #8b4513;">å…è´¹è·å– Gemini Key</a>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸ® æ¸¸æˆçŠ¶æ€</div>
                <div class="status-content">
                    <div>å½“å‰å›åˆ: <span id="currentTurn" style="font-weight:bold;color:#c62828;">çº¢æ–¹ï¼ˆä½ ï¼‰</span></div>
                    <div>ä½ æ˜¯: <span class="player-badge red">çº¢æ–¹</span></div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸ›ï¸ æ“ä½œ</div>
                <button class="btn btn-primary" onclick="startGame()">ğŸ® å¼€å§‹æ–°æ¸¸æˆ</button>
                <button class="btn btn-secondary" onclick="undoMove()">â†©ï¸ æ‚”æ£‹</button>
                <button class="btn btn-danger" onclick="resign()">ğŸ³ï¸ è®¤è¾“</button>
            </div>
            
            <div class="panel-section">
                <div class="section-title">âš™ï¸ è®¾ç½®</div>
                <div class="settings-row">
                    <span>èµ°æ£‹éŸ³æ•ˆ</span>
                    <div class="toggle active" id="soundToggle" onclick="toggleSound()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <div class="settings-row">
                    <span>AI æç¤º</span>
                    <div class="toggle active" id="hintToggle" onclick="toggleHint()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="section-title">ğŸ“ èµ°æ£‹è®°å½•</div>
                <div class="moves-list" id="movesList">
                    <div style="color:#999;text-align:center;">æš‚æ— èµ°æ£‹è®°å½•</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>

    <script>
        // ==================== é…ç½® ====================
        // é»˜è®¤ä½¿ç”¨å…è´¹çš„ Gemini APIï¼ˆå¯èƒ½æœ‰é™é€Ÿï¼‰
        const DEFAULT_API_KEY = ''; // ç”¨æˆ·éœ€è¦è‡ªå·±è¾“å…¥æˆ–ä½¿ç”¨å…è´¹é¢åº¦
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent';
        
        // å¤‡ç”¨ï¼šä½¿ç”¨æœ¬åœ°ç®€å•AIï¼ˆä¸è°ƒç”¨APIï¼‰
        let useLocalAI = false;
        
        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        let gameState = {
            board: [],
            turn: 'red',
            lastMove: null,
            moveCount: 0,
            status: 'waiting',
            moves: [],
            difficulty: 'easy'
        };
        
        let selectedPiece = null;
        let soundEnabled = true;
        let hintEnabled = true;
        let isAIThinking = false;
        let moveHistory = [];
        
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const pieceNames = {
            'R': 'è½¦', 'N': 'é©¬', 'B': 'è±¡', 'A': 'å£«', 'K': 'å°†', 'C': 'ç‚®', 'P': 'å…µ',
            'r': 'è½¦', 'n': 'é©¬', 'b': 'ç›¸', 'a': 'ä»•', 'k': 'å¸…', 'c': 'ç‚®', 'p': 'å’'
        };
        
        // ==================== éŸ³æ•ˆ ====================
        function playSound(type) {
            if (!soundEnabled) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            switch(type) {
                case 'move': oscillator.frequency.value = 400; gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.1); break;
                case 'capture': oscillator.frequency.value = 200; gainNode.gain.setValueAtTime(0.5, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.2); break;
                case 'check': oscillator.frequency.value = 800; gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.3); break;
                case 'win': oscillator.frequency.value = 600; gainNode.gain.setValueAtTime(0.4, audioContext.currentTime); oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.5); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.5); break;
                case 'select': oscillator.frequency.value = 600; gainNode.gain.setValueAtTime(0.2, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.05); break;
            }
        }
        
        function toggleSound() { soundEnabled = !soundEnabled; document.getElementById('soundToggle').classList.toggle('active'); showToast(soundEnabled ? 'éŸ³æ•ˆå·²å¼€å¯' : 'éŸ³æ•ˆå·²å…³é—­'); }
        function toggleHint() { hintEnabled = !hintEnabled; document.getElementById('hintToggle').classList.toggle('active'); showToast(hintEnabled ? 'AIæç¤ºå·²å¼€å¯' : 'AIæç¤ºå·²å…³é—­'); }
        
        function setDifficulty(level) {
            gameState.difficulty = level;
            document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
            showToast(`éš¾åº¦è®¾ç½®ä¸º: ${level === 'easy' ? 'å…¥é—¨' : level === 'medium' ? 'ä¸­çº§' : 'é«˜çº§'}`);
        }
        
        // ==================== åˆå§‹åŒ– ====================
        function init() {
            drawBoard();
            initBoard();
        }
        
        function drawBoard() {
            const hLines = document.getElementById('hLines'), vLines = document.getElementById('vLines');
            for (let i = 0; i < 10; i++) { const line = document.createElement('div'); line.className = 'horizontal-line'; line.style.top = `${i * 50 + 25}px`; hLines.appendChild(line); }
            for (let i = 0; i < 9; i++) {
                if (i === 0 || i === 8) { const line = document.createElement('div'); line.className = 'vertical-line'; line.style.left = `${i * 50 + 25}px`; line.style.top = '25px'; line.style.height = '450px'; vLines.appendChild(line); }
                else {
                    const line1 = document.createElement('div'); line1.className = 'vertical-line'; line1.style.left = `${i * 50 + 25}px`; line1.style.top = '25px'; line1.style.height = '200px'; vLines.appendChild(line1);
                    const line2 = document.createElement('div'); line2.className = 'vertical-line'; line2.style.left = `${i * 50 + 25}px`; line2.style.top = '275px'; line2.style.height = '200px'; vLines.appendChild(line2);
                }
            }
        }
        
        function initBoard() {
            gameState.board = [['R','N','B','A','K','A','B','N','R'],['.','.','.','.','.','.','.','.','.'],['.','C','.','.','.','.','.','C','.'],['P','.','P','.','P','.','P','.','P'],['.','.','.','.','.','.','.','.','.'],['.','.','.','.','.','.','.','.','.'],['p','.','p','.','p','.','p','.','p'],['.','c','.','.','.','.','.','c','.'],['.','.','.','.','.','.','.','.','.'],['r','n','b','a','k','a','b','n','r']];
            gameState.turn = 'red';
            gameState.lastMove = null;
            gameState.moveCount = 0;
            gameState.moves = [];
            gameState.status = 'playing';
            moveHistory = [];
            selectedPiece = null;
            isAIThinking = false;
            updateAIStatus('ç­‰å¾…å¼€å§‹...');
            renderPieces();
            updateUI();
            showToast('æ¸¸æˆå¼€å§‹ï¼çº¢æ–¹å…ˆè¡Œ');
        }
        
        function startGame() {
            initBoard();
        }
        
        // ==================== æ£‹å­æ“ä½œ ====================
        function renderPieces() {
            const container = document.getElementById('piecesContainer');
            container.innerHTML = '';
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece !== '.') {
                        const el = document.createElement('div');
                        el.className = `piece ${piece === piece.toUpperCase() ? 'black' : 'red'}`;
                        if (isAIThinking && piece === piece.toUpperCase()) el.classList.add('ai-thinking');
                        el.textContent = pieceNames[piece];
                        el.style.left = `${col * 50 + 3}px`;
                        el.style.top = `${row * 50 + 3}px`;
                        if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) el.classList.add('selected');
                        if (gameState.lastMove) {
                            const from = gameState.lastMove.from, to = gameState.lastMove.to;
                            if ((row === from.row && col === from.col) || (row === to.row && col === to.col)) el.classList.add('last-move');
                        }
                        if (piece.toUpperCase() === 'K' && isInCheck(piece === piece.toLowerCase())) el.classList.add('check');
                        el.onclick = () => onPieceClick(row, col);
                        container.appendChild(el);
                    }
                }
            }
            if (selectedPiece && !isAIThinking) showMoveHints(selectedPiece.row, selectedPiece.col);
        }
        
        function showMoveHints(row, col) {
            const container = document.getElementById('piecesContainer');
            container.querySelectorAll('.move-hint').forEach(h => h.remove());
            const piece = gameState.board[row][col];
            if (!piece || piece === '.') return;
            const isRed = piece === piece.toLowerCase();
            if (!isRed) return; // åªèƒ½é€‰çº¢æ£‹ï¼ˆç©å®¶ï¼‰
            if (gameState.turn !== 'red') return;
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    if (isValidMove(row, col, r, c)) {
                        const hint = document.createElement('div');
                        hint.className = 'move-hint';
                        hint.style.left = `${c * 50 + 25}px`;
                        hint.style.top = `${r * 50 + 25}px`;
                        hint.onclick = (e) => { e.stopPropagation(); onHintClick(r, c); };
                        container.appendChild(hint);
                    }
                }
            }
        }
        
        function onPieceClick(row, col) {
    if (isAIThinking) { showToast('AIæ€è€ƒä¸­ï¼Œè¯·ç¨å€™...'); return; }
    if (gameState.status !== 'playing') { showToast('æ¸¸æˆå·²ç»“æŸï¼'); return; }
    if (gameState.turn !== 'red') { showToast('è¿˜æ²¡è½®åˆ°ä½ ï¼'); return; }
    
    const piece = gameState.board[row][col];
    if (!piece || piece === '.') return;
    
    const isRed = piece === piece.toLowerCase(); // true=çº¢æ£‹(ç©å®¶), false=é»‘æ£‹(AI)
    
    // å¦‚æœå·²ç»é€‰ä¸­äº†æ£‹å­ï¼Œå°è¯•ç§»åŠ¨æˆ–åƒå­
    if (selectedPiece) {
        if (isValidMove(selectedPiece.row, selectedPiece.col, row, col)) {
            makeMove(selectedPiece.row, selectedPiece.col, row, col);
            selectedPiece = null;
            return;
        }
    }
    
    // åªèƒ½é€‰è‡ªå·±çš„çº¢æ£‹
    if (!isRed) {
        showToast('è¿™æ˜¯AIçš„æ£‹å­');
        return;
    }
    
    playSound('select');
    if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) selectedPiece = null;
    else selectedPiece = { row, col, piece };
    renderPieces();
}
        
        function onHintClick(row, col) {
            if (!selectedPiece || isAIThinking) return;
            makeMove(selectedPiece.row, selectedPiece.col, row, col);
            selectedPiece = null;
        }
        
        // ==================== èµ°æ£‹é€»è¾‘ ====================
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (toRow < 0 || toRow > 9 || toCol < 0 || toCol > 8) return false;
            if (fromRow === toRow && fromCol === toCol) return false;
            const piece = gameState.board[fromRow][fromCol], target = gameState.board[toRow][toCol];
            if (target !== '.' && target !== '') { const isRedPiece = piece === piece.toLowerCase(), isRedTarget = target === target.toLowerCase(); if (isRedPiece === isRedTarget) return false; }
            const type = piece.toUpperCase(), isRed = piece === piece.toLowerCase();
            switch(type) {
                case 'R': return validateRook(fromRow, fromCol, toRow, toCol);
                case 'N': return validateKnight(fromRow, fromCol, toRow, toCol);
                case 'B': return validateBishop(fromRow, fromCol, toRow, toCol, isRed);
                case 'A': return validateAdvisor(fromRow, fromCol, toRow, toCol, isRed);
                case 'K': return validateKing(fromRow, fromCol, toRow, toCol, isRed);
                case 'C': return validateCannon(fromRow, fromCol, toRow, toCol);
                case 'P': return validatePawn(fromRow, fromCol, toRow, toCol, isRed);
                default: return false;
            }
        }
        
        function countPiecesBetween(r1, c1, r2, c2) {
            let count = 0;
            if (r1 === r2) { const min = Math.min(c1, c2), max = Math.max(c1, c2); for (let c = min + 1; c < max; c++) if (gameState.board[r1][c] !== '.' && gameState.board[r1][c] !== '') count++; }
            else if (c1 === c2) { const min = Math.min(r1, r2), max = Math.max(r1, r2); for (let r = min + 1; r < max; r++) if (gameState.board[r][c1] !== '.' && gameState.board[r][c1] !== '') count++; }
            return count;
        }
        
        function validateRook(r1, c1, r2, c2) { if (r1 !== r2 && c1 !== c2) return false; return countPiecesBetween(r1, c1, r2, c2) === 0; }
        function validateKnight(r1, c1, r2, c2) {
            const dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1); if (!((dr === 2 && dc === 1) || (dr === 1 && dc === 2))) return false;
            if (dr === 2) { const blockR = r1 + (r2 > r1 ? 1 : -1); if (gameState.board[blockR][c1] !== '.' && gameState.board[blockR][c1] !== '') return false; }
            else { const blockC = c1 + (c2 > c1 ? 1 : -1); if (gameState.board[r1][blockC] !== '.' && gameState.board[r1][blockC] !== '') return false; }
            return true;
        }
        function validateBishop(r1, c1, r2, c2, isRed) {
            const dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1); if (dr !== 2 || dc !== 2) return false;
            if (isRed && r2 < 5) return false; if (!isRed && r2 > 4) return false;
            const eyeR = (r1 + r2) / 2, eyeC = (c1 + c2) / 2; if (gameState.board[eyeR][eyeC] !== '.' && gameState.board[eyeR][eyeC] !== '') return false;
            return true;
        }
        function validateAdvisor(r1, c1, r2, c2, isRed) {
            const dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1); if (dr !== 1 || dc !== 1) return false;
            if (c2 < 3 || c2 > 5) return false; if (isRed && r2 < 7) return false; if (!isRed && r2 > 2) return false;
            return true;
        }
        function validateKing(r1, c1, r2, c2, isRed) {
            const dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1);
            if (c1 === c2) { let hasPiece = false; const min = Math.min(r1, r2), max = Math.max(r1, r2); for (let r = min + 1; r < max; r++) if (gameState.board[r][c1] !== '.' && gameState.board[r][c1] !== '') { hasPiece = true; break; } if (!hasPiece) { const target = gameState.board[r2][c2]; if (target && (target.toUpperCase() === 'K')) return true; } }
            if (dr + dc !== 1) return false; if (c2 < 3 || c2 > 5) return false; if (isRed && r2 < 7) return false; if (!isRed && r2 > 2) return false;
            return true;
        }
        function validateCannon(r1, c1, r2, c2) {
            if (r1 !== r2 && c1 !== c2) return false;
            const count = countPiecesBetween(r1, c1, r2, c2), target = gameState.board[r2][c2];
            if (target === '.' || target === '') return count === 0;
            else return count === 1;
        }
        function validatePawn(r1, c1, r2, c2, isRed) {
            const dr = r2 - r1, dc = Math.abs(c2 - c1);
            if (isRed) { if (dr > 0) return false; if (r1 >= 5 && dc !== 0) return false; if (dr === -1 && dc === 0) return true; if (r1 < 5 && dr === 0 && dc === 1) return true; }
            else { if (dr < 0) return false; if (r1 <= 4 && dc !== 0) return false; if (dr === 1 && dc === 0) return true; if (r1 > 4 && dr === 0 && dc === 1) return true; }
            return false;
        }
        
        function isInCheck(isRed) {
            let kingRow, kingCol; const kingChar = isRed ? 'k' : 'K';
            for (let r = 0; r < 10; r++) for (let c = 0; c < 9; c++) if (gameState.board[r][c] === kingChar) { kingRow = r; kingCol = c; break; }
            if (kingRow === undefined) return false;
            for (let r = 0; r < 10; r++) for (let c = 0; c < 9; c++) { const piece = gameState.board[r][c]; if (piece !== '.' && piece !== '') { const pieceIsRed = piece === piece.toLowerCase(); if (pieceIsRed !== isRed) if (isValidMove(r, c, kingRow, kingCol)) return true; } }
            return false;
        }
        
        // ==================== æ¸¸æˆæ“ä½œ ====================
        async function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol], target = gameState.board[toRow][toCol], isCapture = target !== '.' && target !== '';
            
            // ä¿å­˜å†å²
            moveHistory.push(JSON.parse(JSON.stringify(gameState.board)));
            
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = '.';
            gameState.moves.push(`${pieceNames[piece]} ${String.fromCharCode(97 + fromCol)}${9-fromRow}â†’${String.fromCharCode(97 + toCol)}${9-toRow}`);
            gameState.lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };
            gameState.moveCount++;
            
            isCapture ? playSound('capture') : playSound('move');
            
            const opponentIsRed = piece === piece.toLowerCase();
            if (isInCheck(!opponentIsRed)) { playSound('check'); showToast('å°†å†›ï¼'); }
            
            if (target && target.toUpperCase() === 'K') {
                const winner = opponentIsRed ? 'é»‘æ–¹' : 'çº¢æ–¹';
                showToast(`ğŸ‰ ${winner}è·èƒœï¼`);
                gameState.status = 'finished';
                playSound('win');
                updateAIStatus('æ¸¸æˆç»“æŸ');
                renderPieces();
                updateUI();
                return;
            }
            
            gameState.turn = gameState.turn === 'red' ? 'black' : 'red';
            updateUI();
            renderPieces();
            
            // AI èµ°æ£‹
            if (gameState.turn === 'black' && gameState.status === 'playing') {
                setTimeout(() => aiMove(), 500);
            }
        }
        
        function updateUI() {
            const turnText = document.getElementById('currentTurn');
            if (gameState.turn === 'red') {
                turnText.textContent = 'çº¢æ–¹ï¼ˆä½ ï¼‰';
                turnText.style.color = '#c62828';
            } else {
                turnText.textContent = 'é»‘æ–¹ï¼ˆAIï¼‰';
                turnText.style.color = '#333';
            }
            
            const movesList = document.getElementById('movesList');
            if (gameState.moves.length === 0) movesList.innerHTML = '<div style="color:#999;text-align:center;">æš‚æ— èµ°æ£‹è®°å½•</div>';
            else {
                movesList.innerHTML = gameState.moves.map((m, i) => {
                    const isRed = i % 2 === 0;
                    return `<div class="move-item"><span class="move-number">${Math.floor(i/2)+1}.</span><span class="${isRed ? 'move-red' : 'move-black'}">${m}</span></div>`;
                }).join('');
                movesList.scrollTop = movesList.scrollHeight;
            }
        }
        
        function updateAIStatus(text) {
            const status = document.getElementById('aiStatus');
            status.textContent = text;
            status.className = 'ai-status' + (text.includes('æ€è€ƒ') ? ' thinking' : '');
        }
        
        // ==================== AI èµ°æ£‹ ====================
        async function aiMove() {
            if (gameState.status !== 'playing') return;
            
            isAIThinking = true;
            updateAIStatus('AI æ€è€ƒä¸­...');
            renderPieces();
            
            try {
                let move;
                const apiKey = document.getElementById('apiKey').value.trim();
                
                if (apiKey && !useLocalAI) {
                    // ä½¿ç”¨ Gemini API
                    move = await getAIMoveFromAPI(apiKey);
                } else {
                    // ä½¿ç”¨æœ¬åœ°ç®€å•AI
                    move = getLocalAIMove();
                }
                
                if (move) {
                    const { from, to } = move;
                    makeMove(from.row, from.col, to.row, to.col);
                    updateAIStatus('ç­‰å¾…ä½ èµ°æ£‹...');
                } else {
                    // AI æ— æ³•èµ°æ£‹ï¼Œå¯èƒ½è¢«å›°
                    showToast('AI è®¤è¾“ï¼ä½ èµ¢äº†ï¼');
                    gameState.status = 'finished';
                    playSound('win');
                    updateAIStatus('AI è®¤è¾“');
                }
            } catch (err) {
                console.error('AI error:', err);
                // API å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°AI
                const move = getLocalAIMove();
                if (move) {
                    const { from, to } = move;
                    makeMove(from.row, from.col, to.row, to.col);
                    updateAIStatus('ç­‰å¾…ä½ èµ°æ£‹...');
                }
            } finally {
                isAIThinking = false;
                renderPieces();
            }
        }
        
        // æœ¬åœ°ç®€å•AIï¼ˆåŸºäºè§„åˆ™ + éšæœºï¼‰
        function getLocalAIMove() {
            const validMoves = [];
            
            // æ”¶é›†æ‰€æœ‰åˆæ³•èµ°æ³•
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    const piece = gameState.board[r][c];
                    if (piece !== '.' && piece === piece.toUpperCase()) { // é»‘æ£‹ï¼ˆAIï¼‰
                        for (let tr = 0; tr < 10; tr++) {
                            for (let tc = 0; tc < 9; tc++) {
                                if (isValidMove(r, c, tr, tc)) {
                                    const target = gameState.board[tr][tc];
                                    let score = 0;
                                    
                                    // è¯„åˆ†ç³»ç»Ÿ
                                    if (target !== '.') {
                                        // åƒå­å¾—åˆ†
                                        const targetType = target.toLowerCase();
                                        const pieceValues = { 'p': 10, 'c': 45, 'r': 90, 'n': 40, 'b': 20, 'a': 20, 'k': 1000 };
                                        score += pieceValues[targetType] || 10;
                                    }
                                    
                                    // å°†å†›å¥–åŠ±
                                    const testBoard = JSON.parse(JSON.stringify(gameState.board));
                                    testBoard[tr][tc] = piece;
                                    testBoard[r][c] = '.';
                                    const originalBoard = gameState.board;
                                    gameState.board = testBoard;
                                    if (isInCheck(true)) score += 50; // å°†å†›çº¢æ–¹
                                    gameState.board = originalBoard;
                                    
                                    // éš¾åº¦è°ƒæ•´
                                    if (gameState.difficulty === 'easy') score *= 0.5;
                                    if (gameState.difficulty === 'hard') score *= 1.5;
                                    
                                    validMoves.push({ from: { row: r, col: c }, to: { row: tr, col: tc }, score: score + Math.random() * 10 });
                                }
                            }
                        }
                    }
                }
            }
            
            if (validMoves.length === 0) return null;
            
            // æ ¹æ®éš¾åº¦é€‰æ‹©
            validMoves.sort((a, b) => b.score - a.score);
            
            if (gameState.difficulty === 'easy') {
                // å…¥é—¨ï¼šä»å‰50%éšæœºé€‰
                const topMoves = validMoves.slice(0, Math.ceil(validMoves.length * 0.5));
                return topMoves[Math.floor(Math.random() * topMoves.length)];
            } else if (gameState.difficulty === 'medium') {
                // ä¸­çº§ï¼šä»å‰30%éšæœºé€‰
                const topMoves = validMoves.slice(0, Math.ceil(validMoves.length * 0.3));
                return topMoves[Math.floor(Math.random() * topMoves.length)];
            } else {
                // é«˜çº§ï¼šé€‰æœ€ä¼˜
                return validMoves[0];
            }
        }
        
        // Gemini API
        async function getAIMoveFromAPI(apiKey) {
            const boardStr = gameState.board.map(row => row.join('')).join('\n');
            const prompt = `ä½ æ˜¯ä¸­å›½è±¡æ£‹AIï¼Œæ‰§é»‘æ£‹ï¼ˆå¤§å†™å­—æ¯ï¼‰ã€‚å½“å‰æ£‹ç›˜ï¼š
${boardStr}
 
æ£‹ç›˜è¯´æ˜ï¼š
- å°å†™å­—æ¯ rnbakcp æ˜¯çº¢æ–¹ï¼ˆå¯¹æ‰‹ï¼‰çš„æ£‹å­ï¼šrè½¦ né©¬ bè±¡ aå£« kå¸… cç‚® på…µ
- å¤§å†™å­—æ¯ RNB AKCP æ˜¯ä½ çš„æ£‹å­ï¼šRè½¦ Né©¬ Bè±¡ Aå£« Kå°† Cç‚® På’
- ä½ æ˜¯é»‘æ–¹ï¼Œè¦æœ€å¤§åŒ–ä½ çš„ä¼˜åŠ¿
 
è¯·åˆ†æå±€é¢ï¼Œé€‰æ‹©æœ€ä½³èµ°æ³•ã€‚åªå›å¤æ ¼å¼ï¼šfromRow,fromCol,toRow,toCol
ä¾‹å¦‚ï¼š0,0,0,1 è¡¨ç¤ºä»(0,0)ç§»åŠ¨åˆ°(0,1)`;
 
            const response = await fetch(`${GEMINI_API_URL}?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.2, maxOutputTokens: 50 }
                })
            });
            
            if (!response.ok) throw new Error('API failed');
            
            const data = await response.json();
            const text = data.candidates[0].content.parts[0].text;
            const match = text.match(/(\d+),(\d+),(\d+),(\d+)/);
            
            if (match) {
                const [_, fr, fc, tr, tc] = match.map(Number);
                if (isValidMove(fr, fc, tr, tc)) {
                    return { from: { row: fr, col: fc }, to: { row: tr, col: tc } };
                }
            }
            
            // API è¿”å›ä¸åˆæ³•ï¼Œå›é€€åˆ°æœ¬åœ°AI
            return getLocalAIMove();
        }
        
        // ==================== å…¶ä»–åŠŸèƒ½ ====================
        function undoMove() {
            if (isAIThinking) { showToast('AIæ€è€ƒä¸­ï¼Œæ— æ³•æ‚”æ£‹'); return; }
            if (moveHistory.length < 2) { showToast('æ— æ³•æ‚”æ£‹'); return; }
            
            // å›é€€ä¸¤æ­¥ï¼ˆç©å®¶å’ŒAIå„ä¸€æ­¥ï¼‰
            moveHistory.pop(); // ç§»é™¤AIçš„èµ°æ³•
            gameState.board = moveHistory.pop(); // æ¢å¤ç©å®¶çš„èµ°æ³•å‰
            
            gameState.turn = 'red';
            gameState.moves = gameState.moves.slice(0, -2);
            gameState.moveCount -= 2;
            gameState.lastMove = null;
            
            renderPieces();
            updateUI();
            showToast('å·²æ‚”æ£‹');
        }
        
        function resign() {
            if (gameState.status !== 'playing') return;
            if (!confirm('ç¡®å®šè¦è®¤è¾“å—ï¼Ÿ')) return;
            showToast('ä½ è®¤è¾“äº†ï¼ŒAIè·èƒœï¼');
            gameState.status = 'finished';
            playSound('win');
            updateAIStatus('AI è·èƒœ');
        }
        
        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }
        
        window.onload = init;
    </script>
</body>
</html>
